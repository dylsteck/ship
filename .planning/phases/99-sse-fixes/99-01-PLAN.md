---
phase: 99-sse-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/lib/e2b.ts
  - apps/api/src/routes/chat.ts
autonomous: true

must_haves:
  truths:
    - 'OpenCode server starts successfully in E2B sandbox within 10 seconds'
    - 'Health check at /health responds with 200 OK'
    - 'Server process logs show startup messages in wrangler logs'
    - "User sees agent responses instead of 'Starting' indefinitely"
  artifacts:
    - path: 'apps/api/src/lib/e2b.ts'
      provides: 'Fixed OpenCode server startup with proper command and error handling'
      exports: ['startOpenCodeServer', 'waitForOpenCodeServer']
    - path: 'apps/api/src/routes/chat.ts'
      provides: 'Better error reporting when OpenCode server fails to start'
      exports: ['POST /:sessionId']
  key_links:
    - from: 'startOpenCodeServer()'
      to: "sandbox.commands.run('opencode serve')"
      via: 'Background process with stdout/stderr capture'
      pattern: 'background: true with onStdout/onStderr handlers'
    - from: 'waitForOpenCodeServer()'
      to: 'curl http://localhost:4096/health'
      via: 'Polling health endpoint with logging'
      pattern: 'curl health check every 1s'
---

<objective>
Fix the OpenCode server startup failure in E2B sandbox. Currently `opencode serve --port 4096` times out after 60 seconds waiting for the /health endpoint. The server never responds, causing all chat requests to hang indefinitely with "Starting" status.

Purpose: Without the OpenCode server running, the agent cannot process messages. This is the root cause of the stuck "Starting" issue.

Output: Working OpenCode server that starts within 10 seconds and responds to health checks.
</objective>

<execution_context>
@/Users/dylansteck/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
# Problem Diagnosis

From wrangler logs:

```
[opencode] Still waiting for server... (30s)
[opencode] Still waiting for server... (40s)
[opencode] Still waiting for server... (50s)
(error) Failed to start OpenCode server in sandbox: Error: OpenCode server failed to start within 60 seconds
```

From E2B dashboard:

- Sandbox is running with code-interpreter-v1 template
- `.opencode` directory exists (OpenCode is installed)
- But health check at port 4096 never responds

# Root Causes to Investigate

1. **Environment variable format**: E2B sandboxes use bash, so `ANTHROPIC_API_KEY=... opencode serve` might not work properly
2. **Working directory**: OpenCode might need to be started from a specific directory
3. **Port binding**: Server might not be binding to 0.0.0.0 (required for external access)
4. **Background process**: The `background: true` might not be working as expected
5. **Missing config**: OpenCode might need a config file or additional setup

# Current Code Issues

In `apps/api/src/lib/e2b.ts`:

```typescript
const proc = await sandbox.commands.run(`ANTHROPIC_API_KEY=${anthropicKey} opencode serve --port 4096`, {
  background: true,
  onStdout: (data: string) => console.log('[opencode]', data),
  onStderr: (data: string) => console.error('[opencode]', data),
})
```

Problems:

- No verification that the process actually started
- No stdout/stderr visible in logs (callbacks might not be firing)
- No alternative approach if this fails
- Environment variable passed inline might not work in sandbox shell
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Fix OpenCode server startup command and add debug logging</name>
  <files>apps/api/src/lib/e2b.ts</files>
  <action>
    Rewrite the `startOpenCodeServer` function to fix server startup issues:

    1. **Change environment variable approach**: Export ANTHROPIC_API_KEY first, then run opencode serve separately
    2. **Add explicit host binding**: Use `--host 0.0.0.0` to ensure external access
    3. **Add working directory**: Run from `/home/user` or the project directory
    4. **Capture and log all output**: Ensure we see stdout/stderr in wrangler logs
    5. **Add verification that process started**: Check process exists before waiting
    6. **Add fallback/retry logic**: If first attempt fails, try alternative approaches
    7. **Check if opencode binary exists and is executable**: Verify installation

    Replace the current `startOpenCodeServer` function with:

    ```typescript
    export async function startOpenCodeServer(
      apiKey: string,
      sandboxId: string,
      anthropicKey: string,
    ): Promise<{ url: string; process: unknown }> {
      const sandbox = await Sandbox.connect(sandboxId, { apiKey })

      console.log(`[opencode:${sandboxId}] Checking if OpenCode is installed...`)

      // Check if opencode binary exists
      const whichResult = await sandbox.commands.run('which opencode || echo "NOT_FOUND"')
      console.log(`[opencode:${sandboxId}] which opencode: ${whichResult.stdout.trim()}`)

      if (whichResult.stdout.includes('NOT_FOUND')) {
        console.log(`[opencode:${sandboxId}] OpenCode not found, checking .opencode directory...`)

        // Check if .opencode exists (installation directory)
        const checkDirResult = await sandbox.commands.run('ls -la ~/.opencode 2>&1 || echo "DIR_NOT_FOUND"')
        console.log(`[opencode:${sandboxId}] .opencode directory: ${checkDirResult.stdout.slice(0, 200)}`)

        // Try to find the binary in common locations
        const findResult = await sandbox.commands.run('find /home -name "opencode" -type f 2>/dev/null | head -5')
        console.log(`[opencode:${sandboxId}] find result: ${findResult.stdout}`)

        // Install OpenCode if not found
        console.log(`[opencode:${sandboxId}] Installing OpenCode CLI...`)
        const installResult = await sandbox.commands.run('curl -fsSL https://opencode.ai/install | bash', {
          timeoutMs: 120000,
          onStdout: (data: string) => console.log(`[opencode:install] ${data}`),
          onStderr: (data: string) => console.error(`[opencode:install] ${data}`),
        })
        console.log(`[opencode:${sandboxId}] Install exit code: ${installResult.exitCode}`)

        if (installResult.exitCode !== 0) {
          throw new Error(`Failed to install OpenCode: ${installResult.stderr}`)
        }
      }

      // Get the actual path to opencode binary
      const opencodePathResult = await sandbox.commands.run('which opencode')
      const opencodePath = opencodePathResult.stdout.trim()
      console.log(`[opencode:${sandboxId}] Using opencode at: ${opencodePath}`)

      // Set up environment and start server
      console.log(`[opencode:${sandboxId}] Starting OpenCode server on port 4096...`)

      // Export env var first, then start server (more reliable than inline env in sandbox)
      const setupCmd = `export ANTHROPIC_API_KEY="${anthropicKey}" && export PATH="$HOME/.opencode/bin:$PATH"`
      await sandbox.commands.run(setupCmd)

      // Start the server as background process with full output capture
      const serverCmd = `cd /home/user && ANTHROPIC_API_KEY="${anthropicKey}" opencode serve --port 4096 --host 0.0.0.0 2>&1`
      console.log(`[opencode:${sandboxId}] Running: ${serverCmd}`)

      const proc = await sandbox.commands.run(serverCmd, {
        background: true,
        onStdout: (data: string) => {
          console.log(`[opencode:server] ${data}`)
        },
        onStderr: (data: string) => {
          console.error(`[opencode:server] ${data}`)
        },
      })

      console.log(`[opencode:${sandboxId}] Server process started, PID check: ${proc ? 'yes' : 'no'}`)

      // Wait a moment for server to initialize
      await new Promise(r => setTimeout(r, 2000))

      // Wait for server to be ready
      await waitForOpenCodeServer(sandbox, 4096)
      console.log(`[opencode:${sandboxId}] Server is ready`)

      // Get public URL for the OpenCode server
      const host = sandbox.getHost(4096)
      const url = `https://${host}`
      console.log(`[opencode:${sandboxId}] Server URL: ${url}`)

      return { url, process: proc }
    }
    ```

  </action>
  <verify>
    Read the file and confirm:
    1. Function checks if opencode binary exists with `which`
    2. Exports ANTHROPIC_API_KEY separately before running server
    3. Uses `--host 0.0.0.0` flag for external access
    4. Has extensive logging at each step
    5. Captures stdout/stderr properly
    6. Has 2 second delay before health check to let server initialize
  </verify>
  <done>
    OpenCode server startup has proper command, environment setup, and debug logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Improve health check with better diagnostics</name>
  <files>apps/api/src/lib/e2b.ts</files>
  <action>
    Update `waitForOpenCodeServer` to:
    1. Log every attempt (not just every 10s)
    2. Try different health check approaches
    3. Check if port is actually listening
    4. Provide detailed diagnostics on failure

    ```typescript
    async function waitForOpenCodeServer(sandbox: Sandbox, port: number, maxAttempts = 60): Promise<void> {
      console.log(`[opencode] Waiting for server on port ${port}...`)

      for (let i = 0; i < maxAttempts; i++) {
        try {
          // Method 1: Try health endpoint
          const result = await sandbox.commands.run(`curl -s -o /dev/null -w "%{http_code}" http://localhost:${port}/health`)
          if (result.stdout.trim() === '200') {
            console.log(`[opencode] Health check passed on attempt ${i + 1}`)
            return
          }

          // Log non-200 responses for debugging
          if (result.stdout.trim() && result.stdout.trim() !== '000') {
            console.log(`[opencode] Health check attempt ${i + 1}: HTTP ${result.stdout.trim()}`)
          }
        } catch (err) {
          // Log error every 5 attempts
          if (i % 5 === 0) {
            console.log(`[opencode] Health check attempt ${i + 1}: ${err instanceof Error ? err.message : 'error'}`)
          }
        }

        // Every 10 seconds, log status and check if process is running
        if (i > 0 && i % 10 === 0) {
          console.log(`[opencode] Still waiting for server... (${i}s)`)

          // Check what's listening on the port
          try {
            const netstatResult = await sandbox.commands.run(`netstat -tlnp 2>/dev/null | grep ${port} || ss -tlnp 2>/dev/null | grep ${port} || echo "No process on port ${port}"`)
            console.log(`[opencode] Port ${port} status: ${netstatResult.stdout.trim()}`)
          } catch {
            // Ignore netstat errors
          }

          // Check if opencode process is running
          try {
            const psResult = await sandbox.commands.run(`ps aux | grep opencode | grep -v grep || echo "No opencode process"`)
            console.log(`[opencode] Process check: ${psResult.stdout.trim().slice(0, 100)}`)
          } catch {
            // Ignore ps errors
          }
        }

        await new Promise((r) => setTimeout(r, 1000))
      }

      // On failure, get detailed diagnostics
      console.error(`[opencode] Server failed to start. Getting diagnostics...`)
      try {
        const psResult = await sandbox.commands.run('ps aux | grep -E "opencode|node" | grep -v grep || echo "No matching processes"')
        console.error(`[opencode] Running processes: ${psResult.stdout}`)
      } catch {}

      try {
        const logResult = await sandbox.commands.run('cat /tmp/opencode.log 2>/dev/null || echo "No log file"')
        console.error(`[opencode] Log file: ${logResult.stdout.slice(0, 500)}`)
      } catch {}

      throw new Error(`OpenCode server failed to start within ${maxAttempts} seconds`)
    }
    ```

  </action>
  <verify>
    Read the file and confirm:
    1. Health check uses `curl -s -o /dev/null -w "%{http_code}"` for HTTP status
    2. Logs non-200 responses
    3. Every 10s checks if port is listening with netstat/ss
    4. Every 10s checks if opencode process is running
    5. On failure, gets process list and log file
  </verify>
  <done>
    Health check has detailed diagnostics to identify why server isn't starting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add server startup error reporting to chat endpoint</name>
  <files>apps/api/src/routes/chat.ts</files>
  <action>
    Update the chat endpoint to better handle and report OpenCode server startup failures:

    Around line 94-110 where `startOpenCodeServer` is called:

    ```typescript
    // If we have a sandbox but no OpenCode URL, start the OpenCode server
    if (sandboxId && !opencodeUrl) {
      try {
        console.log(`[chat:${sessionId}] Starting OpenCode server in sandbox ${sandboxId}...`)
        const { url } = await startOpenCodeServer(c.env.E2B_API_KEY, sandboxId, c.env.ANTHROPIC_API_KEY)
        opencodeUrl = url
        console.log(`[chat:${sessionId}] OpenCode server started at ${url}`)

        // Store the URL for future requests
        await stub.fetch(
          new Request(`${doUrl}/meta`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ opencode_url: url }),
          }),
        )
      } catch (error) {
        console.error(`[chat:${sessionId}] Failed to start OpenCode server in sandbox:`, error)

        // Return error immediately - don't try to stream
        return c.json({
          error: 'Failed to start agent server',
          details: error instanceof Error ? error.message : 'Unknown error',
          sandboxId,
          suggestion: 'The sandbox may need more time to initialize. Please refresh and try again.'
        }, 500)
      }
    }
    ```

    This ensures the user gets a clear error message instead of hanging forever.

  </action>
  <verify>
    Read the file and confirm:
    1. Error is logged with sessionId
    2. Returns 500 JSON response with error details
    3. Includes sandboxId and helpful suggestion in error response
    4. Does NOT proceed to streamSSE if server failed to start
  </verify>
  <done>
    Chat endpoint properly reports OpenCode server startup failures to the user.
  </done>
</task>

<task type="auto">
  <name>Task 4: Test and verify server startup</name>
  <files>apps/api/src/lib/e2b.ts</files>
  <action>
    Add a test helper to verify the OpenCode server can start in a fresh sandbox:

    ```typescript
    /**
     * Test function to verify OpenCode server startup
     * Can be called manually to debug issues
     */
    export async function testOpenCodeServerStartup(apiKey: string, anthropicKey: string): Promise<void> {
      console.log('[test] Creating test sandbox...')
      const sandbox = await Sandbox.betaCreate({ apiKey, autoPause: true })
      console.log(`[test] Sandbox created: ${sandbox.sandboxId}`)

      try {
        console.log('[test] Starting OpenCode server...')
        const { url } = await startOpenCodeServer(apiKey, sandbox.sandboxId, anthropicKey)
        console.log(`[test] SUCCESS! Server running at ${url}`)

        // Test health endpoint from outside
        const healthRes = await fetch(`${url}/health`)
        console.log(`[test] External health check: ${healthRes.status}`)
      } catch (error) {
        console.error('[test] FAILED:', error)
        throw error
      } finally {
        // Cleanup
        await Sandbox.kill(sandbox.sandboxId, { apiKey })
        console.log('[test] Test sandbox cleaned up')
      }
    }
    ```

    This isn't used in production but can be called manually to test the setup.

  </action>
  <verify>
    File has `testOpenCodeServerStartup` function exported for manual testing.
  </verify>
  <done>
    Test helper exists for manual verification of OpenCode server startup.
  </done>
</task>

</tasks>

<verification>
To test after implementing:

1. **Deploy the fix**:

   ```bash
   cd apps/api && wrangler deploy
   ```

2. **Monitor wrangler logs**:

   ```bash
   npx wrangler tail ship-api-production
   ```

3. **Create a new session and send a message**

4. **Expected log sequence**:

   ```
   [opencode:IGWPX...] Checking if OpenCode is installed...
   [opencode:IGWPX...] which opencode: /home/user/.opencode/bin/opencode
   [opencode:IGWPX...] Starting OpenCode server on port 4096...
   [opencode:IGWPX...] Running: cd /home/user && ANTHROPIC_API_KEY="..." opencode serve --port 4096 --host 0.0.0.0 2>&1
   [opencode:server] [INFO] Starting OpenCode server...
   [opencode] Health check attempt 1: HTTP 000
   [opencode] Health check attempt 2: HTTP 000
   ...
   [opencode] Health check passed on attempt 8
   [opencode:IGWPX...] Server is ready
   [opencode:IGWPX...] Server URL: https://4096-xxx.e2b.dev
   [chat:42cd...] OpenCode server started at https://4096-xxx.e2b.dev
   ```

5. **If it still fails**, the detailed diagnostics will show:
   - Whether opencode binary exists
   - Whether process is running
   - What port is listening
   - Server logs

6. **Share the wrangler logs** if issues persist - the detailed output will show exactly where it's failing.
   </verification>

<success_criteria>

- [ ] OpenCode server starts within 10 seconds
- [ ] Health check responds with HTTP 200
- [ ] Server stdout/stderr appears in wrangler logs
- [ ] Detailed diagnostics logged on failure
- [ ] Chat endpoint returns clear error if server fails to start
- [ ] User sees agent responses flowing instead of stuck "Starting"
      </success_criteria>

<output>
After completion, create `.planning/phases/99-sse-fixes/99-01-SUMMARY.md` with:
- Root cause identified
- Fix implemented
- Test results from wrangler logs
- Any remaining issues
</output>
