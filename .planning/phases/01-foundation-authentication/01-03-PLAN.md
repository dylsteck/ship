---
phase: 01-foundation-authentication
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/web/lib/github.ts
  - apps/web/lib/session.ts
  - apps/web/lib/dal.ts
  - apps/web/app/api/auth/github/route.ts
  - apps/web/app/api/auth/github/callback/route.ts
  - apps/web/app/api/auth/logout/route.ts
  - apps/web/middleware.ts
  - apps/web/package.json
  - apps/web/.env.example
autonomous: true
user_setup:
  - service: github-oauth
    why: "GitHub OAuth application for user authentication"
    env_vars:
      - name: GITHUB_CLIENT_ID
        source: "GitHub Settings -> Developer settings -> OAuth Apps -> New OAuth App"
      - name: GITHUB_CLIENT_SECRET
        source: "GitHub Settings -> Developer settings -> OAuth Apps -> Client secrets"
    dashboard_config:
      - task: "Create OAuth App"
        location: "https://github.com/settings/developers"
        details: "Set callback URL to http://localhost:3000/api/auth/github/callback for development"

must_haves:
  truths:
    - "Clicking 'Sign in with GitHub' redirects to GitHub OAuth"
    - "After GitHub auth, user is redirected back with session cookie set"
    - "Session cookie is httpOnly and encrypted with jose"
    - "Accessing protected route without session redirects to login"
  artifacts:
    - path: "apps/web/lib/github.ts"
      provides: "Arctic GitHub OAuth client"
      exports: ["github"]
    - path: "apps/web/lib/session.ts"
      provides: "Session encryption/decryption with jose"
      exports: ["encrypt", "decrypt", "createSession", "deleteSession"]
    - path: "apps/web/lib/dal.ts"
      provides: "Data Access Layer for session verification"
      exports: ["verifySession", "getUser"]
    - path: "apps/web/app/api/auth/github/route.ts"
      provides: "OAuth initiation endpoint"
      exports: ["GET"]
    - path: "apps/web/app/api/auth/github/callback/route.ts"
      provides: "OAuth callback handler"
      exports: ["GET"]
  key_links:
    - from: "apps/web/app/api/auth/github/callback/route.ts"
      to: "apps/web/lib/session.ts"
      via: "createSession() call"
      pattern: "createSession\\("
    - from: "apps/web/lib/dal.ts"
      to: "apps/web/lib/session.ts"
      via: "decrypt() call"
      pattern: "decrypt\\("
    - from: "apps/web/middleware.ts"
      to: "apps/web/lib/session.ts"
      via: "decrypt for optimistic check"
      pattern: "decrypt\\("
---

<objective>
Implement GitHub OAuth flow with Arctic and JWT session management

Purpose: Enable users to sign in with GitHub. This is the core authentication flow that gates access to the application. Uses Arctic for OAuth (lightweight, edge-compatible) and jose for session encryption.

Output:
- GitHub OAuth client using Arctic
- OAuth routes: initiate, callback, logout
- JWT session management with jose (encrypt, decrypt, create, delete)
- Data Access Layer (DAL) for session verification in Server Components
- Middleware for optimistic route protection
</objective>

<execution_context>
@/Users/dylansteck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-CONTEXT.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session management with jose</name>
  <files>
    apps/web/lib/session.ts
    apps/web/lib/dal.ts
    apps/web/package.json
    apps/web/.env.example
  </files>
  <action>
    Install dependencies and create session utilities:

    1. Add to apps/web/package.json dependencies:
       - arctic@^3.7.0
       - jose@^6.1.3

    2. apps/web/.env.example:
       ```
       # GitHub OAuth
       GITHUB_CLIENT_ID=
       GITHUB_CLIENT_SECRET=

       # Session
       SESSION_SECRET=your-32-char-secret-key-here-min

       # API
       API_BASE_URL=http://localhost:8787
       NEXT_PUBLIC_APP_URL=http://localhost:3000
       ```

    3. apps/web/lib/session.ts (following research pattern exactly):
       ```typescript
       import { SignJWT, jwtVerify } from 'jose'
       import { cookies } from 'next/headers'

       const secretKey = process.env.SESSION_SECRET!
       const encodedKey = new TextEncoder().encode(secretKey)

       export interface SessionPayload {
         userId: string
         expiresAt: Date
         createdAt: Date
       }

       export async function encrypt(payload: SessionPayload): Promise<string> {
         return new SignJWT({ ...payload })
           .setProtectedHeader({ alg: 'HS256' })
           .setIssuedAt()
           .setExpirationTime('7d')
           .sign(encodedKey)
       }

       export async function decrypt(session: string | undefined): Promise<SessionPayload | null> {
         if (!session) return null
         try {
           const { payload } = await jwtVerify(session, encodedKey, {
             algorithms: ['HS256'],
           })
           return payload as unknown as SessionPayload
         } catch {
           return null
         }
       }

       export async function createSession(userId: string): Promise<void> {
         const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
         const createdAt = new Date()
         const session = await encrypt({ userId, expiresAt, createdAt })

         const cookieStore = await cookies()
         cookieStore.set('session', session, {
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           expires: expiresAt,
           sameSite: 'lax',
           path: '/',
         })
       }

       export async function deleteSession(): Promise<void> {
         const cookieStore = await cookies()
         cookieStore.delete('session')
       }

       export async function getSession(): Promise<SessionPayload | null> {
         const cookieStore = await cookies()
         const session = cookieStore.get('session')?.value
         return decrypt(session)
       }
       ```

    4. apps/web/lib/dal.ts (Data Access Layer - critical security pattern):
       ```typescript
       import { cache } from 'react'
       import { redirect } from 'next/navigation'
       import { getSession } from './session'

       export const verifySession = cache(async () => {
         const session = await getSession()

         if (!session?.userId) {
           redirect('/login')
         }

         return { isAuth: true, userId: session.userId }
       })

       export const getUser = cache(async () => {
         const session = await verifySession()

         const response = await fetch(`${process.env.API_BASE_URL}/users/${session.userId}`)

         if (!response.ok) {
           redirect('/login')
         }

         return response.json()
       })
       ```
  </action>
  <verify>
    - TypeScript compiles: `cd apps/web && pnpm type-check`
    - Session functions are properly typed
    - DAL exports verifySession and getUser
  </verify>
  <done>
    Session management utilities created with jose encryption and DAL pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub OAuth routes and middleware</name>
  <files>
    apps/web/lib/github.ts
    apps/web/app/api/auth/github/route.ts
    apps/web/app/api/auth/github/callback/route.ts
    apps/web/app/api/auth/logout/route.ts
    apps/web/middleware.ts
  </files>
  <action>
    Create OAuth flow (following research patterns):

    1. apps/web/lib/github.ts:
       ```typescript
       import { GitHub } from 'arctic'

       export const github = new GitHub(
         process.env.GITHUB_CLIENT_ID!,
         process.env.GITHUB_CLIENT_SECRET!,
         `${process.env.NEXT_PUBLIC_APP_URL}/api/auth/github/callback`
       )
       ```

    2. apps/web/app/api/auth/github/route.ts:
       - Generate state with Arctic's generateState()
       - Create authorization URL with scopes: ['read:user', 'user:email']
       - Store state in httpOnly cookie (10 min expiry)
       - Redirect to GitHub

    3. apps/web/app/api/auth/github/callback/route.ts:
       - Validate state from cookie matches query param
       - Exchange code for tokens using github.validateAuthorizationCode()
       - Fetch GitHub user from https://api.github.com/user
       - Fetch primary email if not public from /user/emails
       - POST to API_BASE_URL/users/upsert with GitHub user data
       - Call createSession(userId)
       - Redirect to /onboarding if isNewUser, otherwise /dashboard
       - Handle errors gracefully, redirect to /login?error=auth_failed

    4. apps/web/app/api/auth/logout/route.ts:
       - Call deleteSession()
       - Redirect to /login

    5. apps/web/middleware.ts (OPTIMISTIC checks only - NOT security):
       ```typescript
       import { NextRequest, NextResponse } from 'next/server'
       import { decrypt } from '@/lib/session'

       const protectedRoutes = ['/dashboard', '/settings', '/sessions', '/onboarding']
       const publicRoutes = ['/login', '/']

       export async function middleware(req: NextRequest) {
         const path = req.nextUrl.pathname
         const isProtectedRoute = protectedRoutes.some(route => path.startsWith(route))
         const isPublicRoute = publicRoutes.includes(path)

         const cookie = req.cookies.get('session')?.value
         const session = await decrypt(cookie)

         if (isProtectedRoute && !session?.userId) {
           return NextResponse.redirect(new URL('/login', req.nextUrl))
         }

         if (isPublicRoute && path === '/login' && session?.userId) {
           return NextResponse.redirect(new URL('/dashboard', req.nextUrl))
         }

         return NextResponse.next()
       }

       export const config = {
         matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
       }
       ```

    CRITICAL: Middleware is for UX only. Real security happens in DAL with verifySession().
  </action>
  <verify>
    - `cd apps/web && pnpm dev` starts without errors
    - Navigate to /api/auth/github redirects to GitHub (needs OAuth app configured)
    - /api/auth/logout deletes session cookie
    - Accessing /dashboard without session redirects to /login
  </verify>
  <done>
    GitHub OAuth flow complete with Arctic, session management, and middleware
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. OAuth initiation:
   - GET /api/auth/github sets state cookie and redirects to GitHub
   - State cookie is httpOnly, secure in production

2. OAuth callback (requires GitHub OAuth app):
   - Validates state
   - Creates or updates user via API
   - Sets session cookie
   - Redirects to appropriate page

3. Session management:
   - Session cookie is httpOnly, encrypted
   - decrypt() returns null for invalid sessions
   - deleteSession() removes cookie

4. Middleware:
   - /dashboard redirects to /login without session
   - /login redirects to /dashboard with valid session
</verification>

<success_criteria>
- GitHub OAuth flow initiates correctly (redirects to GitHub)
- Session cookies are properly encrypted with jose
- DAL pattern implemented for secure session verification
- Middleware provides optimistic route protection
- Logout clears session
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-03-SUMMARY.md`
</output>
