---
phase: 03-execution-layer
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/api/src/lib/git-workflow.ts
  - apps/api/src/lib/github.ts
  - apps/api/src/routes/git.ts
  - apps/api/package.json
autonomous: true

must_haves:
  truths:
    - "Agent can clone repository with user token"
    - "Agent creates branch automatically per session"
    - "Agent commits changes per AI response"
    - "Agent pushes to remote automatically"
    - "All git operations use user's GitHub token for attribution"
  artifacts:
    - path: "apps/api/src/lib/git-workflow.ts"
      provides: "Git operations in sandbox (clone, branch, commit, push)"
      exports: ["GitWorkflow", "generateBranchName", "cloneRepo", "commitChanges", "pushBranch"]
    - path: "apps/api/src/lib/github.ts"
      provides: "Octokit client with PR creation"
      exports: ["createGitHubClient", "createPullRequest", "GitHubClient"]
    - path: "apps/api/src/routes/git.ts"
      provides: "Git operations API"
      exports: ["POST /git/clone", "POST /git/commit", "POST /git/push"]
  key_links:
    - from: "git-workflow.ts"
      to: "E2B sandbox"
      via: "sandbox.commands.run()"
      pattern: "sandbox\.commands\.run.*git"
    - from: "github.ts"
      to: "GitHub API"
      via: "Octokit with user token"
      pattern: "new Octokit.*auth.*token"
---

<objective>
Build Git workflow infrastructure for autonomous agent operations. Create utilities for repository cloning, automatic branch creation (with timestamp naming), committing per AI response, and pushing to remote. Build GitHub API wrapper for PR creation using user's token for attribution. Per CONTEXT.md: auto-create branch per session, per-response commits, PRs opened as user.

Purpose: Enable agent to work with Git repositories autonomously - clone, branch, commit, push with proper attribution.

Output: Git workflow utilities, GitHub API client, git operations API routes.
</objective>

<execution_context>
@/Users/dylansteck/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-execution-layer/03-CONTEXT.md
@.planning/phases/03-execution-layer/03-RESEARCH.md
@.planning/phases/03-execution-layer/03-01-SUMMARY.md

# Existing patterns

@apps/api/src/lib/opencode.ts
@apps/api/src/durable-objects/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install GitHub SDK and create GitHub API wrapper</name>
  <files>
    apps/api/package.json
    apps/api/src/lib/github.ts
  </files>
  <action>
    1. Install GitHub SDK:
       - `npm install @octokit/rest octokit-plugin-create-pull-request` in apps/api
    
    2. Create apps/api/src/lib/github.ts:
       - `createGitHubClient(token: string)` - Creates Octokit with auth token
       - `GitHubClient` class wrapping Octokit with:
         - `createPullRequest(params)` - Uses octokit-plugin-create-pull-request
         - `getRepository(owner, repo)` - Get repo info
         - `updatePullRequest(prNumber, updates)` - Mark ready for review
       - Helper: `parseRepoUrl(url)` - Extract owner/repo from GitHub URL
       
    3. Per CONTEXT.md decisions:
       - PRs opened as user (use their GitHub token)
       - Draft PR by default
       - Check for existing PR before creating
    
    4. Pattern from RESEARCH.md Pattern 3:
       - Use octokit-plugin-create-pull-request for simplified PR creation
       - Handle edge cases (large files, encoding)
    
    5. Types: Define interfaces for PR creation params, PR response
    
    IMPORTANT: Never store GitHub tokens in sandbox. Pass per-operation.
  </action>
  <verify>
    - Octokit imports work: `import { Octokit } from '@octokit/rest'`
    - createPullRequest plugin loads correctly
    - TypeScript compiles with GitHub SDK types
  </verify>
  <done>
    GitHub SDK installed, github.ts exports createGitHubClient() and GitHubClient class with PR methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Git workflow utilities for sandbox</name>
  <files>
    apps/api/src/lib/git-workflow.ts
  </files>
  <action>
    Create apps/api/src/lib/git-workflow.ts with Git operations in E2B sandbox:
    
    1. `generateBranchName(taskDescription: string, sessionId: string)`:
       - Format: `ship-{slug}-{timestamp}` per CONTEXT.md
       - Slug: lowercase, replace non-alphanumeric with hyphens, max 30 chars
       - Timestamp: ISO date with hyphens (avoid colons for git safety)
       - Include sessionId suffix for uniqueness
       - Check for git-safe names (no leading/trailing hyphens)
    
    2. `cloneRepo(sandbox, repoUrl, token)`:
       - Insert token into HTTPS URL: `https://token@github.com/...`
       - Clone to /home/user/repo in sandbox
       - Verify clone success
    
    3. `createBranch(sandbox, branchName)`:
       - Run: `git checkout -b {branchName}`
       - Check if branch already exists (handle gracefully)
    
    4. `commitChanges(sandbox, message, user)`:
       - Configure git user: `git config user.name/email`
       - Add all: `git add -A`
       - Commit: `git commit -m "{message}"`
       - Per CONTEXT.md: Per AI response/answer commits
       
    5. `pushBranch(sandbox, branchName, token)`:
       - Use token in remote URL for auth
       - Push: `git push origin {branchName}`
    
    6. Helper: `configureGitUser(sandbox, name, email)` - Sets git config
    
    7. Pattern: All operations use `sandbox.commands.run()` from E2B
    
    Error handling: Check command exit codes, throw on failure with context.
    
    Why structured commands: Type safety and better error handling than raw strings.
  </action>
  <verify>
    - GitWorkflow functions have proper types
    - branchName generation produces valid git branch names
    - All sandbox.commands.run() calls typed correctly
    - TypeScript compiles
  </verify>
  <done>
    git-workflow.ts exports cloneRepo, createBranch, commitChanges, pushBranch, generateBranchName with E2B integration
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Git operations API routes</name>
  <files>
    apps/api/src/routes/git.ts
    apps/api/src/index.ts
  </files>
  <action>
    1. Create apps/api/src/routes/git.ts:
       - `POST /git/clone` - Clone repository to sandbox
         - Body: { sessionId, repoUrl }
         - Uses user's GitHub token from session
         - Returns: { success, branchName, path }
       
       - `POST /git/commit` - Commit changes
         - Body: { sessionId, message }
         - Auto-detects changed files
         - Returns: { success, commitHash }
       
       - `POST /git/push` - Push to remote
         - Body: { sessionId, branchName? }
         - Returns: { success, pushedBranch }
       
       - `POST /git/pr` - Create draft PR
         - Body: { sessionId, title, body? }
         - Auto-creates PR on first commit (per CONTEXT.md)
         - Returns: { prNumber, prUrl, draft }
    
    2. All routes:
       - Get session from SessionDO
       - Get user's GitHub token from session
       - Get sandbox from session
       - Execute git operation
       - Return structured response with error handling
    
    3. Register routes in apps/api/src/index.ts
    
    4. Add validation middleware for all endpoints
    
    Pattern: Routes orchestrate SessionDO + GitWorkflow + GitHubClient.
    
    Why separate route per operation: Agent can call individually or workflow can orchestrate.
  </action>
  <verify>
    - All git routes registered and callable
    - Routes use SessionDO to get sandbox and user token
    - Error responses include meaningful messages
    - TypeScript compiles
  </verify>
  <done>
    Git API routes for /git/clone, /git/commit, /git/push, /git/pr registered and functional
  </done>
</task>

</tasks>

<verification>
1. GitHub SDK installed with octokit-plugin-create-pull-request
2. github.ts exports createGitHubClient() with user token auth
3. git-workflow.ts exports Git operations using E2B commands
4. Branch naming follows ship-{slug}-{timestamp} pattern
5. Git API routes registered and callable
6. All git operations use user's token (not app token)
</verification>

<success_criteria>

- Agent can clone repository using user's GitHub token
- Branch names generated as ship-{slug}-{timestamp} with session ID
- Commits use user's git config (name/email from GitHub)
- Pushes authenticated with user's token
- GitHub client can create draft PRs
  </success_criteria>

<output>
After completion, create `.planning/phases/03-execution-layer/03-03-SUMMARY.md`
</output>
