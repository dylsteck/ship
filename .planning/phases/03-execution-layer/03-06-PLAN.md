---
phase: 03-execution-layer
plan: 06
type: execute
wave: 4
depends_on: ["03-04", "03-05"]
files_modified:
  - apps/api/src/lib/error-handler.ts
  - apps/api/src/lib/agent-executor.ts
  - apps/web/components/chat/error-message.tsx
  - apps/web/components/chat/chat-interface.tsx
  - apps/web/components/chat/message-list.tsx
autonomous: true

must_haves:
  truths:
    - "Errors displayed inline in chat as system message"
    - "Transient errors auto-retry with exponential backoff"
    - "Persistent errors pause agent and notify user"
    - "Retry button shown for failed operations"
    - "User can open VS Code or Terminal from error message"
  artifacts:
    - path: "apps/api/src/lib/error-handler.ts"
      provides: "Error classification and retry logic"
      exports: ["classifyError", "executeWithRetry", "ErrorCategory"]
    - path: "apps/web/components/chat/error-message.tsx"
      provides: "Error display with actions"
      exports: ["ErrorMessage"]
  key_links:
    - from: "error-handler.ts"
      to: "AgentExecutor"
      via: "wrap agent operations with executeWithRetry"
      pattern: "executeWithRetry.*operation"
    - from: "ErrorMessage"
      to: "ChatInterface"
      via: "render in message list"
      pattern: "message\.type === 'error'"
---

<objective>
Implement comprehensive error handling and recovery per CONTEXT.md: Classify errors as transient (auto-retry) vs persistent (pause and notify). Display errors inline in chat with retry button and options to open VS Code or Terminal. Use exponential backoff with jitter for retries. Agent decides recovery based on error type.

Purpose: Ensure agent execution is resilient - transient issues auto-recover, persistent issues notify user with actionable options.

Output: Error classification system, retry logic with backoff, error display component with actions.
</objective>

<execution_context>
@/Users/dylansteck/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-execution-layer/03-CONTEXT.md
@.planning/phases/03-execution-layer/03-RESEARCH.md
@.planning/phases/03-execution-layer/03-04-SUMMARY.md
@.planning/phases/03-execution-layer/03-05-SUMMARY.md

# Existing files

@apps/api/src/lib/agent-executor.ts
@apps/web/components/chat/chat-interface.tsx
@apps/web/components/chat/message-list.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error classification and retry utilities</name>
  <files>
    apps/api/src/lib/error-handler.ts
  </files>
  <action>
    Create apps/api/src/lib/error-handler.ts per RESEARCH.md Pattern 6:
    
    1. Error categories enum:
       - `transient` - Network, rate limit, timeout (auto-retry)
       - `persistent` - Auth, permission, logic error (pause & notify)
       - `user-action` - Needs user decision (prompt via UI)
       - `fatal` - Unrecoverable (abort task)
    
    2. `classifyError(error: unknown): ErrorDetails`:
       - Parse error message
       - Pattern matching for error types:
         - Transient: ECONNRESET, ETIMEDOUT, 429, "rate limit", "timeout", "temporary"
         - User-action: "permission", "unauthorized", "confirm", "approve"
         - Persistent: "authentication", "not found", "invalid", "failed"
       - Return: { category, retryable, maxRetries, backoffMs }
       - Default to fatal if pattern doesn't match
    
    3. `executeWithRetry<T>(operation, context)`:
       - Try operation
       - If fails: classify error
       - If retryable: exponential backoff (2s, 4s, 8s... up to maxRetries)
       - Call onError callback for each retry attempt
       - Throw last error if all retries fail
    
    4. `sleep(ms)` utility with optional jitter (add random 0-100ms to prevent thundering herd)
    
    5. Types: ErrorCategory, ErrorDetails, RetryContext
    
    Pattern from RESEARCH.md:
    - Transient: 3 retries, 2s base backoff
    - Exponential: delay * 2^(attempt-1)
    - Add jitter: delay + Math.random() * 100
    
    Why classification: Different errors need different UX. Transient = silent retry, Persistent = notify user.
  </action>
  <verify>
    - classifyError correctly categorizes common error patterns
    - executeWithRetry implements exponential backoff
    - Jitter added to prevent synchronized retries
    - TypeScript compiles
  </verify>
  <done>
    error-handler.ts exports classifyError(), executeWithRetry(), ErrorCategory enum with retry logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate error handling into AgentExecutor</name>
  <files>
    apps/api/src/lib/agent-executor.ts
  </files>
  <action>
    Update apps/api/src/lib/agent-executor.ts with error handling:
    
    1. Wrap operations with executeWithRetry:
       - Sandbox commands (git operations)
       - GitHub API calls (PR creation)
       - OpenCode operations (if not already handled by SDK)
    
    2. Add error event emission:
       - `onError(error: Error, category: ErrorCategory, context: string)` callback
       - Emit error details to session for UI display
       - Include: error message, category, retryable, actions available
    
    3. Per-error-type behavior:
       - Transient: Auto-retry with backoff, emit "Retrying..." message
       - Persistent: Pause agent, emit error to chat with VS Code/Terminal buttons
       - User-action: Pause and wait for user response (permission request)
       - Fatal: Abort task, emit error, mark task failed
    
    4. Add recovery state:
       - `isPaused` flag on AgentExecutor
       - `pause()` and `resume()` methods
       - On persistent error: pause agent, wait for user action
       - Resume continues from last checkpoint
    
    5. Error context:
       - Include operation name ("git commit", "push", "PR creation")
       - Include sandbox ID, session ID for debugging
       - Sanitize: Don't include tokens in error messages
    
    Pattern: Error handling is part of execution flow, not just logging. UX depends on error category.
  </action>
  <verify>
    - AgentExecutor uses executeWithRetry for git operations
    - Error events emitted with category and context
    - Pause/resume logic implemented
    - TypeScript compiles
  </verify>
  <done>
    AgentExecutor integrates error classification, auto-retry for transient errors, pause for persistent errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create error message component and integrate into chat</name>
  <files>
    apps/web/components/chat/error-message.tsx
    apps/web/components/chat/message-list.tsx
    apps/web/components/chat/chat-interface.tsx
  </files>
  <action>
    1. Create apps/web/components/chat/error-message.tsx:
       - Props: {
           message: string;
           category: 'transient' | 'persistent' | 'user-action' | 'fatal';
           retryable: boolean;
           onRetry?: () => void;
           onOpenVSCode?: () => void;
           onOpenTerminal?: () => void;
         }
       - Styled card with:
         - Error icon (AlertCircle from lucide-react)
         - Error title based on category ("Temporary Error", "Error", "Action Required")
         - Error message
         - Action buttons (conditional):
           - Retry button (if retryable)
           - "Open VS Code" button (if persistent error)
           - "Open Terminal" button (if persistent error)
       - Color coding:
         - Transient: yellow/amber warning style
         - Persistent: red destructive style
         - User-action: blue info style
         - Fatal: red with stronger emphasis
    
    2. Update apps/web/components/chat/message-list.tsx:
       - Add case for message.type === 'error'
       - Render ErrorMessage component
       - Pass callbacks for actions
    
    3. Update apps/web/components/chat/chat-interface.tsx:
       - Handle error messages from WebSocket/SSE
       - Implement onRetry: Call API to retry failed operation
       - Implement onOpenVSCode/onOpenTerminal: Open respective drawers
       - Show error in message stream (as system message)
    
    4. Pattern from CONTEXT.md:
       - Inline in chat (not modal)
       - Retry button for failed operations
       - VS Code/Terminal access from error for manual intervention
    
    Why inline: Keeps context - user sees error in conversation flow where it happened.
  </action>
  <verify>
    - ErrorMessage component renders all categories correctly
    - Action buttons call correct callbacks
    - MessageList shows error messages inline
    - ChatInterface handles error actions
    - TypeScript compiles
  </verify>
  <done>
    ErrorMessage component with category styling and action buttons, integrated into chat message list
  </done>
</task>

</tasks>

<verification>
1. Error classification categorizes common patterns correctly
2. Transient errors retry with exponential backoff (2s, 4s, 8s)
3. Persistent errors pause agent and show in chat
4. ErrorMessage component shows retry and VS Code/Terminal buttons
5. Error display is inline in chat (not modal)
6. Jitter added to prevent thundering herd
</verification>

<success_criteria>

- Errors classified as transient/persistent/user-action/fatal
- Transient errors auto-retry with exponential backoff (max 3 retries)
- Persistent errors displayed inline in chat with action buttons
- User can click Retry to retry failed operations
- User can open VS Code or Terminal from error message
- Agent pauses on persistent errors, resumes after user action or retry success
  </success_criteria>

<output>
After completion, create `.planning/phases/03-execution-layer/03-06-SUMMARY.md`
</output>
