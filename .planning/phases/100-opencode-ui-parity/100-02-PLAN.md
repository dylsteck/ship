---
phase: 100-opencode-ui-parity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/sse-types.ts (new)
  - apps/web/lib/sse-parser.ts (new)
  - apps/web/components/chat/message-part.tsx (new)
autonomous: true

must_haves:
  truths:
    - 'All OpenCode SSE event types are defined with TypeScript interfaces'
    - 'SSE events can be parsed and typed correctly'
    - 'Message parts have dedicated render components'
  artifacts:
    - path: 'apps/web/lib/sse-types.ts'
      provides: 'TypeScript types for all SSE events'
      exports: ['SSEEvent', 'MessagePart', 'ToolPart', 'TextPart', 'ReasoningPart']
    - path: 'apps/web/lib/sse-parser.ts'
      provides: 'SSE event parsing and normalization'
      exports: ['parseSSEEvent', 'normalizeEvent']
    - path: 'apps/web/components/chat/message-part.tsx'
      provides: 'Part rendering components'
      exports: ['MessagePartDisplay', 'ToolPartDisplay', 'TextPartDisplay']
  key_links:
    - from: 'sse-parser.ts'
      to: 'sse-types.ts'
      via: 'import types'
---

<objective>
Create typed SSE event system matching OpenCode event structure

Purpose: The SSE stream sends rich events (message.part.updated, message.updated, session.status, tool calls with input/output, reasoning, file changes) but the current code handles them ad-hoc with lots of type casting. Create a proper typed system like OpenCode uses.

Output: Type-safe SSE event handling with dedicated types for each event and part type
</objective>

<execution_context>
@/Users/dylansteck/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
Based on the SSE event breakdown provided, the events include:
- status events (initializing, provisioning, sandbox-ready, etc.)
- message.part.updated with part types: text, tool, reasoning, step-start, step-finish
- message.updated with message info
- session.updated with session info
- session.status (busy, idle)
- session.idle
- heartbeat
- done
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE type definitions</name>
  <files>apps/web/lib/sse-types.ts</files>
  <action>
Create a new file with comprehensive TypeScript types for all SSE events:

```typescript
// apps/web/lib/sse-types.ts

// ============ Base Types ============

export type ToolState = {
  status: 'pending' | 'running' | 'completed' | 'error'
  input: Record<string, unknown>
  raw?: string
  title?: string
  output?: string
  metadata?: Record<string, unknown>
  time?: {
    start: number
    end?: number
  }
}

export type TextPart = {
  id: string
  sessionID: string
  messageID: string
  type: 'text'
  text: string
  time?: {
    start: number
    end?: number
  }
}

export type ToolPart = {
  id: string
  sessionID: string
  messageID: string
  type: 'tool'
  callID: string
  tool: string
  state: ToolState
}

export type ReasoningPart = {
  id: string
  sessionID: string
  messageID: string
  type: 'reasoning'
  text: string
}

export type StepStartPart = {
  id: string
  sessionID: string
  messageID: string
  type: 'step-start'
  snapshot: string
}

export type StepFinishPart = {
  id: string
  sessionID: string
  messageID: string
  type: 'step-finish'
  reason: 'stop' | 'tool-calls' | 'unknown'
  snapshot: string
  cost: number
  tokens: {
    input: number
    output: number
    reasoning: number
    cache: { read: number; write: number }
  }
}

export type MessagePart = TextPart | ToolPart | ReasoningPart | StepStartPart | StepFinishPart

// ============ Message Types ============

export type UserMessage = {
  id: string
  sessionID: string
  role: 'user'
  time: { created: number }
  summary?: { title?: string; diffs: unknown[] }
  agent: string
  model: { providerID: string; modelID: string }
}

export type AssistantMessage = {
  id: string
  sessionID: string
  role: 'assistant'
  time: { created: number; completed?: number }
  parentID: string
  modelID: string
  providerID: string
  mode: 'build' | 'plan'
  agent: string
  path: { cwd: string; root: string }
  cost: number
  tokens: {
    input: number
    output: number
    reasoning: number
    cache: { read: number; write: number }
  }
  finish?: 'stop' | 'tool-calls' | 'unknown'
  error?: { name: string; data: { message: string } }
}

export type Message = UserMessage | AssistantMessage

// ============ Session Types ============

export type SessionInfo = {
  id: string
  slug: string
  version: string
  projectID: string
  directory: string
  title: string
  time: { created: number; updated: number }
  summary: { additions: number; deletions: number; files: number }
  share?: { url: string }
}

export type SessionStatus =
  | { type: 'idle' }
  | { type: 'busy' }
  | { type: 'retry'; attempt: number; message: string; next: number }

// ============ SSE Event Types ============

export type StatusEvent = {
  type: 'status'
  status: string
  message: string
  toolName?: string
  toolStatus?: string
  toolTitle?: string
}

export type MessagePartUpdatedEvent = {
  type: 'message.part.updated'
  properties: {
    part: MessagePart
    delta?: string
  }
}

export type MessageUpdatedEvent = {
  type: 'message.updated'
  properties: {
    info: Message
  }
}

export type SessionUpdatedEvent = {
  type: 'session.updated'
  properties: {
    info: SessionInfo
  }
}

export type SessionStatusEvent = {
  type: 'session.status'
  properties: {
    sessionID: string
    status: SessionStatus
  }
}

export type SessionIdleEvent = {
  type: 'session.idle'
  properties: {
    sessionID: string
  }
}

export type SessionDiffEvent = {
  type: 'session.diff'
  properties: {
    sessionID: string
    diff: Array<{
      filename: string
      additions: number
      deletions: number
    }>
  }
}

export type TodoUpdatedEvent = {
  type: 'todo.updated'
  properties: {
    sessionID: string
    todos: Array<{
      id: string
      content: string
      status: 'pending' | 'in_progress' | 'completed' | 'cancelled'
      priority: 'high' | 'medium' | 'low'
    }>
  }
}

export type FileWatcherEvent = {
  type: 'file-watcher.updated'
  properties: {
    event: 'create' | 'modify' | 'delete'
    path: string
  }
}

export type ServerConnectedEvent = {
  type: 'server.connected'
  properties: Record<string, never>
}

export type ServerHeartbeatEvent = {
  type: 'server.heartbeat'
  properties: Record<string, never>
}

export type HeartbeatEvent = {
  type: 'heartbeat'
  message: string
  eventCount: number
  timeSinceLastEvent: number
}

export type DoneEvent = {
  type: 'done'
}

export type ErrorEvent = {
  type: 'error'
  error: string
  category?: 'transient' | 'persistent' | 'user-action' | 'fatal'
  retryable?: boolean
  details?: string
}

export type SSEEvent =
  | StatusEvent
  | MessagePartUpdatedEvent
  | MessageUpdatedEvent
  | SessionUpdatedEvent
  | SessionStatusEvent
  | SessionIdleEvent
  | SessionDiffEvent
  | TodoUpdatedEvent
  | FileWatcherEvent
  | ServerConnectedEvent
  | ServerHeartbeatEvent
  | HeartbeatEvent
  | DoneEvent
  | ErrorEvent

// ============ Type Guards ============

export function isMessagePartUpdated(event: SSEEvent): event is MessagePartUpdatedEvent {
  return event.type === 'message.part.updated'
}

export function isToolPart(part: MessagePart): part is ToolPart {
  return part.type === 'tool'
}

export function isTextPart(part: MessagePart): part is TextPart {
  return part.type === 'text'
}

export function isReasoningPart(part: MessagePart): part is ReasoningPart {
  return part.type === 'reasoning'
}

export function isStepFinish(part: MessagePart): part is StepFinishPart {
  return part.type === 'step-finish'
}
```

  </action>
  <verify>
Run `npx tsc --noEmit apps/web/lib/sse-types.ts` to verify types compile without errors.
  </verify>
  <done>All SSE event types are defined and compile correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create SSE event parser</name>
  <files>apps/web/lib/sse-parser.ts</files>
  <action>
Create a parser that takes raw SSE data and returns typed events:

```typescript
// apps/web/lib/sse-parser.ts

import type { SSEEvent, MessagePart, ToolPart, TextPart } from './sse-types'

/**
 * Parse raw SSE event data into typed event
 */
export function parseSSEEvent(data: unknown): SSEEvent | null {
  if (!data || typeof data !== 'object') return null

  const event = data as Record<string, unknown>

  // Handle wrapped events (server sends event inside 'event' field sometimes)
  if (event.event && typeof event.event === 'object') {
    return parseSSEEvent(event.event)
  }

  const type = event.type
  if (typeof type !== 'string') return null

  return event as SSEEvent
}

/**
 * Extract text content from a message.part.updated event
 */
export function extractTextDelta(event: SSEEvent): string | null {
  if (event.type !== 'message.part.updated') return null

  const part = event.properties.part
  if (part.type !== 'text') return null

  // Prefer delta (incremental) over full text
  const delta = event.properties.delta
  if (typeof delta === 'string') return delta

  return (part as TextPart).text || null
}

/**
 * Extract tool info from a message.part.updated event
 */
export function extractToolInfo(event: SSEEvent): {
  callID: string
  tool: string
  status: string
  title?: string
  input?: unknown
  output?: string
} | null {
  if (event.type !== 'message.part.updated') return null

  const part = event.properties.part
  if (part.type !== 'tool') return null

  const toolPart = part as ToolPart
  return {
    callID: toolPart.callID,
    tool: toolPart.tool,
    status: toolPart.state.status,
    title: toolPart.state.title,
    input: toolPart.state.input,
    output: toolPart.state.output,
  }
}

/**
 * Get a human-readable status from an event
 */
export function getEventStatus(event: SSEEvent): { label: string; icon: string } | null {
  switch (event.type) {
    case 'status':
      return getStatusFromStatusEvent(event)
    case 'message.part.updated':
      return getStatusFromPartEvent(event)
    case 'session.status':
      return { label: event.properties.status.type, icon: event.properties.status.type === 'busy' ? 'üîÑ' : '‚úÖ' }
    case 'heartbeat':
      return { label: `Waiting (${event.timeSinceLastEvent}s)`, icon: '‚è≥' }
    default:
      return null
  }
}

function getStatusFromStatusEvent(event: { type: 'status'; status: string; message: string }): {
  label: string
  icon: string
} {
  const statusIcons: Record<string, string> = {
    initializing: 'üöÄ',
    provisioning: 'üì¶',
    'sandbox-ready': '‚úÖ',
    'starting-opencode': 'üîå',
    cloning: 'üì•',
    'repo-ready': '‚úÖ',
    'creating-session': 'üîß',
    'sending-prompt': 'üì§',
    'agent-active': '‚ö°',
    'tool-call': 'üîß',
    'agent-thinking': 'üí≠',
  }

  return {
    label: event.message,
    icon: statusIcons[event.status] || 'üì°',
  }
}

function getStatusFromPartEvent(event: {
  type: 'message.part.updated'
  properties: { part: MessagePart }
}): { label: string; icon: string } | null {
  const part = event.properties.part

  switch (part.type) {
    case 'tool': {
      const toolPart = part as ToolPart
      const toolName = toolPart.tool.toLowerCase()

      if (toolName.includes('read') || toolName.includes('glob') || toolName.includes('grep')) {
        return { label: `Reading: ${toolPart.state.title || 'files...'}`, icon: 'üîç' }
      }
      if (toolName.includes('write') || toolName.includes('edit')) {
        return { label: `Writing: ${toolPart.state.title || 'code...'}`, icon: '‚úèÔ∏è' }
      }
      if (toolName.includes('bash') || toolName.includes('run') || toolName.includes('shell')) {
        return { label: `Running: ${toolPart.state.title || 'command...'}`, icon: '‚ö°' }
      }
      if (toolName.includes('task') || toolName.includes('agent')) {
        return { label: 'Creating task...', icon: 'üìã' }
      }
      return { label: `${toolPart.tool}: ${toolPart.state.title || ''}`, icon: 'üîß' }
    }
    case 'text':
      return { label: 'Writing response...', icon: '‚úçÔ∏è' }
    case 'reasoning':
      return { label: 'Reasoning...', icon: 'üí≠' }
    case 'step-start':
      return { label: 'Starting step...', icon: 'üöÄ' }
    case 'step-finish':
      return { label: 'Step complete', icon: '‚úÖ' }
    default:
      return null
  }
}

/**
 * Get cost info from step-finish event
 */
export function extractCostInfo(event: SSEEvent): {
  cost: number
  tokens: { input: number; output: number; reasoning: number; cacheRead: number; cacheWrite: number }
} | null {
  if (event.type !== 'message.part.updated') return null

  const part = event.properties.part
  if (part.type !== 'step-finish') return null

  return {
    cost: part.cost,
    tokens: {
      input: part.tokens.input,
      output: part.tokens.output,
      reasoning: part.tokens.reasoning,
      cacheRead: part.tokens.cache.read,
      cacheWrite: part.tokens.cache.write,
    },
  }
}
```

  </action>
  <verify>
Run `npx tsc --noEmit apps/web/lib/sse-parser.ts` to verify parser compiles.
  </verify>
  <done>SSE parser functions implemented and type-safe</done>
</task>

</tasks>

<verification>
1. Both new files compile without TypeScript errors
2. Type definitions cover all event types from the SSE breakdown
3. Parser functions correctly extract data from events
</verification>

<success_criteria>

- All SSE event types are defined in sse-types.ts
- Type guards allow safe narrowing of event types
- Parser extracts text deltas, tool info, and status correctly
- Cost/token info can be extracted from step-finish events
  </success_criteria>

<output>
After completion, create `.planning/phases/100-opencode-ui-parity/100-02-SUMMARY.md`
</output>
