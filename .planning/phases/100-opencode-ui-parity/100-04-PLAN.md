---
phase: 100-opencode-ui-parity
plan: 04
type: execute
wave: 3
depends_on: [100-02, 100-03]
files_modified:
  - apps/web/app/(app)/dashboard/dashboard-client.tsx
  - apps/web/components/chat/chat-interface.tsx
autonomous: true

must_haves:
  truths:
    - 'SSE events are processed using typed parser'
    - 'All tool calls display in the activity feed'
    - 'Step costs and tokens are displayed'
    - 'Session sidebar shows live context and status'
  artifacts:
    - path: 'apps/web/app/(app)/dashboard/dashboard-client.tsx'
      provides: 'Integrated SSE handling with new components'
    - path: 'apps/web/components/chat/chat-interface.tsx'
      provides: 'Integrated SSE handling with new components'
  key_links:
    - from: 'dashboard-client.tsx'
      to: 'sse-parser.ts'
      via: 'import parseSSEEvent'
    - from: 'dashboard-client.tsx'
      to: 'SessionActivity'
      via: 'renders activity feed'
---

<objective>
Integrate new SSE types and components into existing chat interfaces

Purpose: Replace the ad-hoc SSE handling with the typed parser and render rich activity using the new components. This connects all the pieces to show users what OpenCode shows in its TUI.

Output: Dashboard and chat interface display rich agent activity with tools, costs, and session details
</objective>

<execution_context>
@/Users/dylansteck/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@apps/web/lib/sse-types.ts
@apps/web/lib/sse-parser.ts
@apps/web/components/chat/tool-display.tsx
@apps/web/components/chat/session-activity.tsx
@apps/web/components/chat/session-sidebar.tsx
@apps/web/app/(app)/dashboard/dashboard-client.tsx
@apps/web/components/chat/chat-interface.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update dashboard-client.tsx with typed SSE handling</name>
  <files>apps/web/app/(app)/dashboard/dashboard-client.tsx</files>
  <action>
Refactor the SSE handling in dashboard-client.tsx to use the typed parser and new components:

1. Add imports at the top:

```tsx
import { parseSSEEvent, extractTextDelta, extractToolInfo, getEventStatus, extractCostInfo } from '@/lib/sse-parser'
import type { SSEEvent, ToolPart as SSEToolPart, StepFinishPart } from '@/lib/sse-types'
import { SessionActivity } from '@/components/chat/session-activity'
import { SessionSidebar } from '@/components/chat/session-sidebar'
```

2. Update the state to track richer data:

```tsx
// Replace thinkingParts state with typed version
const [activityTools, setActivityTools] = useState<SSEToolPart[]>([])
const [lastStepCost, setLastStepCost] = useState<{ cost: number; tokens: StepFinishPart['tokens'] } | null>(null)
const [sessionTodos, setSessionTodos] = useState<
  Array<{ id: string; content: string; status: 'pending' | 'in_progress' | 'completed' | 'cancelled' }>
>([])
const [fileDiffs, setFileDiffs] = useState<Array<{ filename: string; additions: number; deletions: number }>>([])
const [contextTokens, setContextTokens] = useState<number>(0)
const [totalCost, setTotalCost] = useState<number>(0)
```

3. In the SSE processing loop, replace ad-hoc parsing with typed parsing:

```tsx
for (const line of lines) {
  if (line.startsWith('data: ')) {
    try {
      const rawData = JSON.parse(line.slice(6))
      const event = parseSSEEvent(rawData)
      if (!event) continue

      // Handle based on event type
      switch (event.type) {
        case 'message.part.updated': {
          const part = event.properties.part

          // Handle text parts
          if (part.type === 'text') {
            const delta = event.properties.delta
            if (typeof delta === 'string') {
              assistantTextRef.current += delta
            } else if (part.text) {
              assistantTextRef.current = part.text
            }
            setMessages((prev) =>
              prev.map((m) => (m.id === streamingMessageRef.current ? { ...m, content: assistantTextRef.current } : m)),
            )
          }

          // Handle tool parts
          if (part.type === 'tool') {
            const toolPart: SSEToolPart = {
              id: part.id,
              sessionID: part.sessionID,
              messageID: part.messageID,
              type: 'tool',
              callID: part.callID,
              tool: part.tool,
              state: part.state,
            }
            setActivityTools((prev) => {
              const existing = prev.findIndex((t) => t.callID === toolPart.callID)
              if (existing >= 0) {
                return prev.map((t, i) => (i === existing ? toolPart : t))
              }
              return [...prev, toolPart]
            })

            // Update status label
            const statusInfo = getEventStatus(event)
            if (statusInfo) {
              setThinkingStatus(`${statusInfo.icon} ${statusInfo.label}`)
            }
          }

          // Handle reasoning parts
          if (part.type === 'reasoning' && part.text) {
            setThinkingReasoning((prev) => (prev ? `${prev}\n\n${part.text}` : part.text))
            setThinkingStatus('ðŸ’­ Reasoning...')
          }

          // Handle step-finish for cost tracking
          if (part.type === 'step-finish') {
            const costInfo = extractCostInfo(event)
            if (costInfo) {
              setLastStepCost(costInfo)
              setTotalCost((prev) => prev + costInfo.cost)
              setContextTokens(costInfo.tokens.input + costInfo.tokens.output + costInfo.tokens.reasoning)
            }
          }
          break
        }

        case 'status': {
          const statusInfo = getEventStatus(event)
          if (statusInfo) {
            setThinkingStatus(`${statusInfo.icon} ${statusInfo.label}`)
          }
          break
        }

        case 'todo.updated': {
          const todos = event.properties.todos
          setSessionTodos(todos)
          break
        }

        case 'session.diff': {
          setFileDiffs(event.properties.diff)
          break
        }

        case 'done':
        case 'session.idle': {
          setIsStreaming(false)
          setThinkingStatus('')
          streamingMessageRef.current = null
          // Don't clear activity tools immediately - let user see them
          setTimeout(() => {
            setActivityTools([])
            setLastStepCost(null)
          }, 3000)
          break
        }

        case 'error': {
          const errorMessage: Message = {
            id: `error-${Date.now()}`,
            role: 'system',
            content: event.error,
            type: 'error',
            errorCategory: event.category || 'persistent',
            retryable: event.retryable || false,
            createdAt: Math.floor(Date.now() / 1000),
          }
          setMessages((prev) => [...prev, errorMessage])
          setIsStreaming(false)
          setThinkingStatus('')
          break
        }
      }
    } catch {
      // Ignore parse errors
    }
  }
}
```

4. Replace ThinkingIndicator with SessionActivity:

```tsx
{
  /* Replace ThinkingIndicator with SessionActivity */
}
{
  isStreaming && (activityTools.length > 0 || thinkingStatus) && (
    <div className="animate-in fade-in-0 slide-in-from-bottom-2 duration-300">
      <SessionActivity
        isStreaming={isStreaming}
        tools={activityTools}
        statusLabel={thinkingStatus}
        lastStepCost={lastStepCost || undefined}
        expanded={thinkingExpanded}
        onToggleExpand={() => setThinkingExpanded(!thinkingExpanded)}
      />
    </div>
  )
}
```

5. Replace the right panel with SessionSidebar:

```tsx
{
  /* Replace inline right panel with SessionSidebar */
}
{
  activeSessionId && (
    <SessionSidebar
      repoOwner={selectedRepo?.owner}
      repoName={selectedRepo?.name}
      modelId={selectedModel?.id}
      modelName={selectedModel?.name}
      provider={selectedModel?.provider}
      mode={mode}
      contextTokens={contextTokens}
      contextPercentage={contextTokens > 0 ? Math.round((contextTokens / 200000) * 100) : undefined}
      totalCost={totalCost}
      isStreaming={isStreaming}
      statusLabel={thinkingStatus}
      todos={sessionTodos}
      fileDiffs={fileDiffs}
    />
  )
}
```

  </action>
  <verify>
Run `npm run dev` and test with a session:
1. Send a message
2. Verify SessionActivity shows tools as they execute
3. Verify SessionSidebar shows context and status updates
4. Check console for any TypeScript errors
  </verify>
  <done>Dashboard uses typed SSE parsing and new activity components</done>
</task>

<task type="auto">
  <name>Task 2: Update chat-interface.tsx with same improvements</name>
  <files>apps/web/components/chat/chat-interface.tsx</files>
  <action>
Apply the same refactoring to chat-interface.tsx:

1. Add the same imports:

```tsx
import { parseSSEEvent, extractTextDelta, extractToolInfo, getEventStatus, extractCostInfo } from '@/lib/sse-parser'
import type { SSEEvent, ToolPart as SSEToolPart, StepFinishPart } from '@/lib/sse-types'
import { SessionActivity } from './session-activity'
```

2. Update state to match dashboard-client.tsx:

```tsx
const [activityTools, setActivityTools] = useState<SSEToolPart[]>([])
const [lastStepCost, setLastStepCost] = useState<{ cost: number; tokens: StepFinishPart['tokens'] } | null>(null)
```

3. Replace the SSE processing in handleSend with the typed version (same pattern as dashboard-client).

4. Replace ThinkingIndicator with SessionActivity:

```tsx
{
  /* Show SessionActivity when streaming */
}
{
  isStreaming && (activityTools.length > 0 || thinkingReasoning || thinkingStatus) && (
    <div className="px-6 pb-6">
      <SessionActivity
        isStreaming={isStreaming}
        tools={activityTools}
        statusLabel={thinkingStatus || currentTool || 'Processing...'}
        lastStepCost={lastStepCost || undefined}
        expanded={thinkingExpanded}
        onToggleExpand={() => setThinkingExpanded(!thinkingExpanded)}
      />
    </div>
  )
}
```

5. Reset activity state on stream end:

```tsx
// In the done/session.idle handler:
setIsStreaming(false)
streamingMessageRef.current = null
setTimeout(() => {
  setActivityTools([])
  setThinkingReasoning('')
  setThinkingStatus('')
  setLastStepCost(null)
}, 2000)
```

  </action>
  <verify>
Test the session page (/session/[id]) with same verification steps as Task 1.
  </verify>
  <done>Chat interface uses typed SSE parsing and SessionActivity component</done>
</task>

</tasks>

<verification>
1. Send a message on dashboard
2. See SessionActivity showing each tool as it executes
3. See tools expand when running, collapse when complete
4. See cost/token display after step completion
5. See SessionSidebar update with context info
6. Same experience on session page
</verification>

<success_criteria>

- Dashboard shows rich activity feed with tools
- Session page shows same rich activity
- All tool calls visible with input/output
- Costs and tokens displayed per step
- Sidebar shows live session metadata
- No TypeScript errors
- No React rendering errors (the original React error #31)
  </success_criteria>

<output>
After completion, create `.planning/phases/100-opencode-ui-parity/100-04-SUMMARY.md`
</output>
