---
phase: 02-stateful-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/api/src/durable-objects/session.ts
  - apps/api/src/routes/sessions.ts
  - apps/web/lib/websocket.ts
autonomous: true

must_haves:
  truths:
    - "Client can establish WebSocket connection to session DO"
    - "Connection survives DO hibernation"
    - "Client auto-reconnects on disconnect"
    - "Server broadcasts messages to all connected clients"
  artifacts:
    - path: "apps/api/src/durable-objects/session.ts"
      provides: "WebSocket handling with hibernation"
      contains: "ctx.acceptWebSocket"
      min_lines: 120
    - path: "apps/web/lib/websocket.ts"
      provides: "Reconnecting WebSocket client"
      exports: ["createReconnectingWebSocket"]
      min_lines: 50
  key_links:
    - from: "apps/web/lib/websocket.ts"
      to: "/sessions/:id/websocket"
      via: "WebSocket connection"
      pattern: "new WebSocket"
    - from: "apps/api/src/durable-objects/session.ts"
      to: "WebSocket handlers"
      via: "hibernation API"
      pattern: "webSocketMessage|webSocketClose"
---

<objective>
Implement WebSocket infrastructure for real-time session updates.

Purpose: Real-time updates are core to the chat experience - users need to see agent responses as they stream. This implements the WebSocket Hibernation API on server and reconnecting WebSocket client, enabling SESS-05 (real-time status updates).

Output: Working bidirectional WebSocket connection between client and session DO that survives hibernation and auto-reconnects.
</objective>

<execution_context>
@/Users/dylansteck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-stateful-core/02-RESEARCH.md
@.planning/phases/02-stateful-core/02-01-SUMMARY.md

# Existing files
@apps/api/src/durable-objects/session.ts
@apps/api/src/routes/sessions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebSocket Hibernation support to SessionDO</name>
  <files>apps/api/src/durable-objects/session.ts</files>
  <action>
Extend SessionDO with WebSocket Hibernation API following Cloudflare patterns from research.

Add to SessionDO class:

1. Track connections using ctx.getWebSockets() on wake (not in-memory Map):
```typescript
private getConnections(): Map<WebSocket, ConnectionState> {
  const connections = new Map<WebSocket, ConnectionState>();
  for (const ws of this.ctx.getWebSockets()) {
    const state = ws.deserializeAttachment() as ConnectionState;
    if (state) connections.set(ws, state);
  }
  return connections;
}
```

2. Handle WebSocket upgrade in fetch():
```typescript
async fetch(request: Request): Promise<Response> {
  const url = new URL(request.url);

  if (url.pathname.endsWith('/websocket')) {
    const upgradeHeader = request.headers.get('Upgrade');
    if (upgradeHeader !== 'websocket') {
      return new Response('Expected WebSocket', { status: 426 });
    }
    return this.handleWebSocketUpgrade(request);
  }

  // ... other routes
}

private handleWebSocketUpgrade(request: Request): Response {
  const pair = new WebSocketPair();
  const [client, server] = Object.values(pair);

  // Use Hibernation API - DO can sleep while connection stays open
  this.ctx.acceptWebSocket(server);

  // Store connection state that survives hibernation
  const state: ConnectionState = {
    connectedAt: Date.now(),
    lastSeen: Date.now(),
  };
  server.serializeAttachment(state);

  return new Response(null, { status: 101, webSocket: client });
}
```

3. Implement WebSocket event handlers (required for Hibernation API):
```typescript
async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
  const state = ws.deserializeAttachment() as ConnectionState;
  state.lastSeen = Date.now();
  ws.serializeAttachment(state);

  // Parse and handle message
  const data = JSON.parse(message as string);

  // Echo for now - real handling in later plans
  this.broadcast({ type: 'echo', data });
}

async webSocketClose(ws: WebSocket, code: number, reason: string) {
  // CRITICAL: Must reciprocate close to avoid 1006 errors
  ws.close(code, reason);
}

async webSocketError(ws: WebSocket, error: unknown) {
  console.error('WebSocket error:', error);
  ws.close(1011, 'Internal error');
}
```

4. Add broadcast helper:
```typescript
private broadcast(message: object) {
  const json = JSON.stringify(message);
  for (const ws of this.ctx.getWebSockets()) {
    try {
      ws.send(json);
    } catch (e) {
      // Connection may be closing, ignore
    }
  }
}
```

5. Add types at top of file:
```typescript
interface ConnectionState {
  connectedAt: number;
  lastSeen: number;
  userId?: string;
}
```

IMPORTANT from research:
- Use ctx.acceptWebSocket() NOT server.accept() (enables hibernation)
- Always reciprocate close in webSocketClose handler
- Don't store WebSocket refs in class properties - use ctx.getWebSockets()
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
TypeScript recognizes webSocketMessage, webSocketClose, webSocketError methods.
  </verify>
  <done>SessionDO handles WebSocket connections with Hibernation API.</done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket upgrade route</name>
  <files>apps/api/src/routes/sessions.ts</files>
  <action>
Add WebSocket upgrade endpoint to sessions routes.

The upgrade route passes the request to the appropriate DO:
```typescript
// GET /sessions/:id/websocket - WebSocket upgrade
app.get('/:id/websocket', async (c) => {
  const sessionId = c.req.param('id');

  // Verify session exists in D1 (optional, adds latency)
  // For now, trust the ID and let DO handle it

  // Get DO stub and forward the request
  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  // Forward the WebSocket upgrade request to DO
  return stub.fetch(c.req.raw);
});
```

Note: The actual WebSocket handling happens in the DO, but we need a route to forward the upgrade request.

Also add a route to forward other DO requests for future use:
```typescript
// Forward requests to DO (for future RPC methods)
app.all('/:id/do/*', async (c) => {
  const sessionId = c.req.param('id');
  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);
  return stub.fetch(c.req.raw);
});
```
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
Route exists at /sessions/:id/websocket.
  </verify>
  <done>WebSocket upgrade route forwards to SessionDO.</done>
</task>

<task type="auto">
  <name>Task 3: Create reconnecting WebSocket client</name>
  <files>apps/web/lib/websocket.ts</files>
  <action>
Create the client-side WebSocket utility with exponential backoff reconnection.

Follow the pattern from research:
```typescript
// apps/web/lib/websocket.ts

export type WebSocketStatus = 'connecting' | 'connected' | 'disconnected';

export interface WebSocketOptions {
  url: string;
  onMessage: (data: unknown) => void;
  onStatusChange?: (status: WebSocketStatus) => void;
}

export interface ReconnectingWebSocket {
  send: (data: unknown) => void;
  disconnect: () => void;
  getStatus: () => WebSocketStatus;
}

export function createReconnectingWebSocket(options: WebSocketOptions): ReconnectingWebSocket {
  let ws: WebSocket | null = null;
  let reconnectAttempts = 0;
  let status: WebSocketStatus = 'disconnected';
  let shouldReconnect = true;

  const maxAttempts = 10;
  const baseDelay = 1000;
  const maxDelay = 30000;

  function setStatus(newStatus: WebSocketStatus) {
    status = newStatus;
    options.onStatusChange?.(newStatus);
  }

  function connect() {
    if (!shouldReconnect) return;

    setStatus('connecting');
    ws = new WebSocket(options.url);

    ws.onopen = () => {
      reconnectAttempts = 0;
      setStatus('connected');
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        options.onMessage(data);
      } catch {
        console.error('Failed to parse WebSocket message:', event.data);
      }
    };

    ws.onclose = (event) => {
      setStatus('disconnected');
      // Don't reconnect on clean close (1000) or if intentionally disconnected
      if (shouldReconnect && event.code !== 1000) {
        scheduleReconnect();
      }
    };

    ws.onerror = () => {
      // Error will trigger close, let close handler deal with reconnect
    };
  }

  function scheduleReconnect() {
    if (reconnectAttempts >= maxAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }

    // Exponential backoff with jitter (from research)
    const delay = Math.min(
      baseDelay * Math.pow(2, reconnectAttempts),
      maxDelay
    );
    const jitter = delay * 0.5 * Math.random();

    setTimeout(() => {
      reconnectAttempts++;
      connect();
    }, delay + jitter);
  }

  function send(data: unknown) {
    if (ws?.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(data));
    } else {
      console.warn('WebSocket not connected, cannot send');
    }
  }

  function disconnect() {
    shouldReconnect = false;
    ws?.close(1000, 'Client disconnected');
    ws = null;
  }

  function getStatus() {
    return status;
  }

  // Connect immediately
  connect();

  return { send, disconnect, getStatus };
}
```

Key features from CONTEXT.md:
- "Auto-reconnect WebSocket silently in background"
- Uses exponential backoff with jitter to prevent thundering herd
- Clean API for components to use
  </action>
  <verify>
Run `pnpm -F web build` - compiles without errors.
Export createReconnectingWebSocket exists.
  </verify>
  <done>Reconnecting WebSocket client utility created with exponential backoff.</done>
</task>

</tasks>

<verification>
1. `pnpm -F api build` and `pnpm -F web build` pass
2. Start API with `pnpm -F api dev`
3. Test WebSocket connection with wscat or browser:
   ```
   wscat -c ws://localhost:8787/sessions/test-session/websocket
   ```
4. Send message, receive echo back
5. Kill and restart server - client should reconnect
</verification>

<success_criteria>
- WebSocket connection establishes to session DO
- Connection survives DO hibernation (test by waiting >10s)
- Messages broadcast to all connected clients
- Client auto-reconnects on disconnect with backoff
- Foundation ready for real-time chat updates (Plan 02-05)
</success_criteria>

<output>
After completion, create `.planning/phases/02-stateful-core/02-03-SUMMARY.md`
</output>
