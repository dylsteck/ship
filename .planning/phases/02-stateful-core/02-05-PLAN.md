---
phase: 02-stateful-core
plan: 05
type: execute
wave: 4
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - apps/web/app/(app)/session/[id]/page.tsx
  - apps/web/components/chat/chat-interface.tsx
  - apps/web/components/chat/message-list.tsx
  - apps/web/components/chat/chat-input.tsx
  - apps/web/components/chat/tool-block.tsx
  - apps/web/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User can view session page with chat interface"
    - "User can send messages via chat input"
    - "Messages appear in message list"
    - "Real-time updates arrive via WebSocket"
    - "User can stop streaming response"
    - "User can queue follow-up messages"
  artifacts:
    - path: "apps/web/app/(app)/session/[id]/page.tsx"
      provides: "Session page with chat"
      min_lines: 30
    - path: "apps/web/components/chat/chat-interface.tsx"
      provides: "Main chat component"
      exports: ["ChatInterface"]
      min_lines: 80
    - path: "apps/web/components/chat/message-list.tsx"
      provides: "Message rendering"
      exports: ["MessageList"]
      min_lines: 40
    - path: "apps/web/components/chat/chat-input.tsx"
      provides: "Chat input with controls"
      exports: ["ChatInput"]
      min_lines: 40
  key_links:
    - from: "apps/web/components/chat/chat-interface.tsx"
      to: "apps/web/lib/websocket.ts"
      via: "createReconnectingWebSocket"
      pattern: "createReconnectingWebSocket"
    - from: "apps/web/components/chat/chat-interface.tsx"
      to: "/chat/:sessionId"
      via: "fetch POST for messages"
      pattern: "fetch.*chat"
---

<objective>
Build the chat UI with real-time WebSocket integration.

Purpose: This is the primary user interface - where users interact with the agent. The chat interface needs to handle message display, streaming responses, tool call rendering, stop/queue controls, and real-time updates. Delivers core of SESS-02 (chat in session) and SESS-05 (real-time updates).

Output: Complete chat interface with message list, input, real-time updates, and streaming support.
</objective>

<execution_context>
@/Users/dylansteck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-stateful-core/02-CONTEXT.md
@.planning/phases/02-stateful-core/02-02-SUMMARY.md
@.planning/phases/02-stateful-core/02-03-SUMMARY.md
@.planning/phases/02-stateful-core/02-04-SUMMARY.md

# Existing files
@apps/web/lib/websocket.ts
@apps/web/lib/api.ts
@apps/web/lib/dal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat components</name>
  <files>apps/web/components/chat/message-list.tsx, apps/web/components/chat/chat-input.tsx, apps/web/components/chat/tool-block.tsx</files>
  <action>
Create the foundational chat components following CONTEXT.md decisions.

1. Create apps/web/components/chat/message-list.tsx:
```tsx
'use client';

import { ToolBlock } from './tool-block';

export interface MessagePart {
  type: 'text' | 'tool-call' | 'tool-result';
  content?: string;
  toolName?: string;
  toolInput?: unknown;
  toolOutput?: unknown;
  state?: 'pending' | 'running' | 'complete' | 'error';
}

export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  parts?: MessagePart[];
  createdAt: number;
}

interface MessageListProps {
  messages: Message[];
  isStreaming?: boolean;
  onLoadEarlier?: () => void;
  hasMore?: boolean;
}

export function MessageList({ messages, isStreaming, onLoadEarlier, hasMore }: MessageListProps) {
  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4">
      {hasMore && (
        <button
          onClick={onLoadEarlier}
          className="w-full text-sm text-gray-500 hover:text-gray-700 py-2"
        >
          Load earlier messages
        </button>
      )}

      {messages.map((message) => (
        <div
          key={message.id}
          className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
        >
          <div
            className={`max-w-[80%] rounded-lg px-4 py-2 ${
              message.role === 'user'
                ? 'bg-blue-600 text-white'
                : 'bg-gray-100 text-gray-900'
            }`}
          >
            {/* Render text content */}
            {message.content && (
              <div className="whitespace-pre-wrap">{message.content}</div>
            )}

            {/* Render tool parts */}
            {message.parts?.map((part, i) => {
              if (part.type === 'tool-call' || part.type === 'tool-result') {
                return (
                  <ToolBlock
                    key={i}
                    name={part.toolName || 'Unknown'}
                    input={part.toolInput}
                    output={part.toolOutput}
                    state={part.state}
                  />
                );
              }
              return null;
            })}
          </div>
        </div>
      ))}

      {isStreaming && (
        <div className="flex justify-start">
          <div className="bg-gray-100 rounded-lg px-4 py-2">
            <div className="flex items-center gap-2">
              <div className="animate-pulse">Thinking...</div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
```

2. Create apps/web/components/chat/chat-input.tsx:
```tsx
'use client';

import { useState, KeyboardEvent } from 'react';

interface ChatInputProps {
  onSend: (content: string) => void;
  onStop: () => void;
  isStreaming: boolean;
  queueCount?: number;
  disabled?: boolean;
}

export function ChatInput({ onSend, onStop, isStreaming, queueCount = 0, disabled }: ChatInputProps) {
  const [input, setInput] = useState('');

  const handleSubmit = () => {
    if (!input.trim()) return;
    onSend(input.trim());
    setInput('');
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };

  return (
    <div className="border-t p-4 bg-white">
      <div className="flex gap-2">
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={isStreaming ? 'Message will be queued...' : 'Type a message...'}
          disabled={disabled}
          className="flex-1 resize-none rounded-lg border border-gray-300 px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100"
          rows={2}
        />

        <div className="flex flex-col gap-2">
          {isStreaming ? (
            <button
              onClick={onStop}
              className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
            >
              Stop
            </button>
          ) : (
            <button
              onClick={handleSubmit}
              disabled={disabled || !input.trim()}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Send
            </button>
          )}
        </div>
      </div>

      {queueCount > 0 && (
        <div className="mt-2 text-sm text-gray-500">
          {queueCount} message{queueCount > 1 ? 's' : ''} queued
        </div>
      )}
    </div>
  );
}
```

3. Create apps/web/components/chat/tool-block.tsx:
Per CONTEXT.md: "Tool blocks collapsed by default to keep chat readable"
```tsx
'use client';

import { useState } from 'react';

interface ToolBlockProps {
  name: string;
  input?: unknown;
  output?: unknown;
  state?: 'pending' | 'running' | 'complete' | 'error';
}

export function ToolBlock({ name, input, output, state = 'complete' }: ToolBlockProps) {
  const [expanded, setExpanded] = useState(false);

  const stateColors = {
    pending: 'bg-gray-200 text-gray-600',
    running: 'bg-blue-100 text-blue-700',
    complete: 'bg-green-100 text-green-700',
    error: 'bg-red-100 text-red-700',
  };

  return (
    <div className="mt-2 border rounded-lg overflow-hidden">
      <button
        onClick={() => setExpanded(!expanded)}
        className={`w-full px-3 py-2 flex items-center justify-between ${stateColors[state]}`}
      >
        <span className="font-mono text-sm">{name}</span>
        <span className="text-xs">
          {state === 'running' && 'Running...'}
          {state === 'pending' && 'Pending'}
          {state === 'complete' && (expanded ? 'Collapse' : 'Expand')}
          {state === 'error' && 'Error'}
        </span>
      </button>

      {expanded && (
        <div className="p-3 bg-gray-50 text-sm font-mono">
          {input && (
            <div className="mb-2">
              <div className="text-xs text-gray-500 mb-1">Input:</div>
              <pre className="whitespace-pre-wrap text-xs">
                {JSON.stringify(input, null, 2)}
              </pre>
            </div>
          )}
          {output && (
            <div>
              <div className="text-xs text-gray-500 mb-1">Output:</div>
              <pre className="whitespace-pre-wrap text-xs">
                {typeof output === 'string' ? output : JSON.stringify(output, null, 2)}
              </pre>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```
  </action>
  <verify>
Run `pnpm -F web build` - compiles without errors.
All component files exist and export correctly.
  </verify>
  <done>MessageList, ChatInput, and ToolBlock components created.</done>
</task>

<task type="auto">
  <name>Task 2: Create ChatInterface with WebSocket integration</name>
  <files>apps/web/components/chat/chat-interface.tsx, apps/web/lib/api.ts</files>
  <action>
Create the main ChatInterface component that ties everything together.

1. Add chat API functions to apps/web/lib/api.ts:
```typescript
// Add to existing api.ts

export async function sendChatMessage(sessionId: string, content: string): Promise<Response> {
  return fetch(`${API_URL}/chat/${sessionId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content }),
  });
}

export async function getChatMessages(
  sessionId: string,
  options?: { limit?: number; before?: string }
): Promise<Message[]> {
  const params = new URLSearchParams();
  if (options?.limit) params.set('limit', options.limit.toString());
  if (options?.before) params.set('before', options.before);

  const res = await fetch(`${API_URL}/chat/${sessionId}/messages?${params}`);
  if (!res.ok) throw new Error('Failed to fetch messages');
  return res.json();
}

export async function stopChatStream(sessionId: string): Promise<void> {
  await fetch(`${API_URL}/chat/${sessionId}/stop`, { method: 'POST' });
}
```

2. Create apps/web/components/chat/chat-interface.tsx:
Following CONTEXT.md decisions:
- Token-by-token streaming
- Stop button AND message queuing
- Recent messages shown by default (~25)
- Real-time WebSocket updates

```tsx
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { MessageList, Message, MessagePart } from './message-list';
import { ChatInput } from './chat-input';
import { createReconnectingWebSocket, WebSocketStatus } from '@/lib/websocket';
import { sendChatMessage, getChatMessages, stopChatStream } from '@/lib/api';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8787';

interface ChatInterfaceProps {
  sessionId: string;
}

export function ChatInterface({ sessionId }: ChatInterfaceProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [messageQueue, setMessageQueue] = useState<string[]>([]);
  const [wsStatus, setWsStatus] = useState<WebSocketStatus>('disconnected');
  const [hasMore, setHasMore] = useState(false);
  const wsRef = useRef<ReturnType<typeof createReconnectingWebSocket>>();
  const streamingMessageRef = useRef<string | null>(null);

  // Load initial messages
  useEffect(() => {
    async function loadMessages() {
      try {
        const msgs = await getChatMessages(sessionId, { limit: 25 });
        setMessages(msgs);
        setHasMore(msgs.length === 25);
      } catch (err) {
        console.error('Failed to load messages:', err);
      }
    }
    loadMessages();
  }, [sessionId]);

  // Connect WebSocket for real-time updates
  useEffect(() => {
    const wsUrl = `${API_URL.replace('http', 'ws')}/sessions/${sessionId}/websocket`;

    wsRef.current = createReconnectingWebSocket({
      url: wsUrl,
      onMessage: (data: unknown) => {
        const event = data as { type: string; message?: Message; messageId?: string; parts?: string };

        if (event.type === 'message') {
          // New message from another client or server
          setMessages((prev) => {
            const exists = prev.some((m) => m.id === event.message?.id);
            if (exists) return prev;
            return [...prev, event.message!];
          });
        }

        if (event.type === 'message-parts') {
          // Update streaming message parts
          setMessages((prev) =>
            prev.map((m) =>
              m.id === event.messageId
                ? { ...m, parts: JSON.parse(event.parts || '[]') }
                : m
            )
          );
        }
      },
      onStatusChange: setWsStatus,
    });

    return () => wsRef.current?.disconnect();
  }, [sessionId]);

  // Process queued messages when streaming completes
  useEffect(() => {
    if (!isStreaming && messageQueue.length > 0) {
      const [next, ...rest] = messageQueue;
      setMessageQueue(rest);
      handleSend(next);
    }
  }, [isStreaming, messageQueue]);

  const handleSend = useCallback(async (content: string) => {
    if (isStreaming) {
      // Queue message per CONTEXT.md: "message queuing available"
      setMessageQueue((q) => [...q, content]);
      return;
    }

    setIsStreaming(true);

    // Optimistically add user message
    const userMessage: Message = {
      id: `temp-${Date.now()}`,
      role: 'user',
      content,
      createdAt: Math.floor(Date.now() / 1000),
    };
    setMessages((prev) => [...prev, userMessage]);

    // Create placeholder for assistant message
    const assistantId = `temp-assistant-${Date.now()}`;
    streamingMessageRef.current = assistantId;
    const assistantMessage: Message = {
      id: assistantId,
      role: 'assistant',
      content: '',
      parts: [],
      createdAt: Math.floor(Date.now() / 1000),
    };
    setMessages((prev) => [...prev, assistantMessage]);

    try {
      const response = await sendChatMessage(sessionId, content);

      if (!response.body) {
        throw new Error('No response body');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));

              if (data.type === 'assistant') {
                // Update assistant message with final content
                setMessages((prev) =>
                  prev.map((m) =>
                    m.id === streamingMessageRef.current
                      ? { ...m, content: data.content, id: data.id || m.id }
                      : m
                  )
                );
              }

              if (data.type === 'done') {
                setIsStreaming(false);
                streamingMessageRef.current = null;
              }
            } catch {
              // Ignore parse errors
            }
          }
        }
      }
    } catch (err) {
      console.error('Chat error:', err);
      setIsStreaming(false);
      streamingMessageRef.current = null;
    }
  }, [sessionId, isStreaming]);

  const handleStop = useCallback(async () => {
    try {
      await stopChatStream(sessionId);
    } catch {
      // Ignore stop errors
    }
    setIsStreaming(false);
    streamingMessageRef.current = null;
  }, [sessionId]);

  const handleLoadEarlier = useCallback(async () => {
    if (messages.length === 0) return;

    const firstMessage = messages[0];
    const earlier = await getChatMessages(sessionId, {
      limit: 25,
      before: firstMessage.id,
    });

    if (earlier.length < 25) setHasMore(false);
    setMessages((prev) => [...earlier, ...prev]);
  }, [sessionId, messages]);

  return (
    <div className="flex flex-col h-full bg-white">
      {/* Connection status indicator */}
      {wsStatus !== 'connected' && (
        <div className="px-4 py-2 bg-yellow-100 text-yellow-800 text-sm">
          {wsStatus === 'connecting' ? 'Connecting...' : 'Disconnected - Reconnecting...'}
        </div>
      )}

      <MessageList
        messages={messages}
        isStreaming={isStreaming}
        onLoadEarlier={handleLoadEarlier}
        hasMore={hasMore}
      />

      <ChatInput
        onSend={handleSend}
        onStop={handleStop}
        isStreaming={isStreaming}
        queueCount={messageQueue.length}
      />
    </div>
  );
}
```
  </action>
  <verify>
Run `pnpm -F web build` - compiles without errors.
ChatInterface component exports correctly.
  </verify>
  <done>ChatInterface created with WebSocket real-time updates and streaming support.</done>
</task>

<task type="auto">
  <name>Task 3: Create session page</name>
  <files>apps/web/app/(app)/session/[id]/page.tsx</files>
  <action>
Create the session page that renders the chat interface.

Create apps/web/app/(app)/session/[id]/page.tsx:
```tsx
import { verifySession } from '@/lib/dal';
import { ChatInterface } from '@/components/chat/chat-interface';
import Link from 'next/link';

interface SessionPageProps {
  params: Promise<{ id: string }>;
}

export default async function SessionPage({ params }: SessionPageProps) {
  // Verify auth
  await verifySession();

  const { id: sessionId } = await params;

  return (
    <div className="flex flex-col h-screen">
      {/* Header */}
      <header className="flex items-center justify-between px-4 py-3 border-b">
        <div className="flex items-center gap-4">
          <Link
            href="/dashboard"
            className="text-gray-500 hover:text-gray-700"
          >
            &larr; Back
          </Link>
          <h1 className="font-semibold">Session</h1>
        </div>
      </header>

      {/* Chat Interface */}
      <div className="flex-1 overflow-hidden">
        <ChatInterface sessionId={sessionId} />
      </div>
    </div>
  );
}
```

Note: The side panel (repo context, branch, tasks) will be added in Plan 02-07.
For now, focus on the core chat experience.

Also ensure the session list links to this page:
In apps/web/components/session/session-list.tsx, each session card should link to `/session/${session.id}`.
  </action>
  <verify>
Run `pnpm -F web build` - compiles without errors.
Navigate to /session/[id] in browser - page renders with chat interface.
  </verify>
  <done>Session page created with chat interface.</done>
</task>

</tasks>

<verification>
1. `pnpm -F web build` passes
2. Start both API and web: `pnpm dev`
3. Create a session from dashboard
4. Click session to open chat
5. Send a message - appears in list
6. Response streams back (placeholder for now)
7. Open same session in second browser tab - messages sync via WebSocket
8. WebSocket reconnects after disconnect
</verification>

<success_criteria>
- User can view session with chat interface (Success Criteria #2)
- User can send messages and see them in list
- Messages persist across page reloads
- Real-time updates work via WebSocket (Success Criteria #5)
- Stop button works during streaming
- Message queuing works when streaming
- "Load earlier" pagination works
</success_criteria>

<output>
After completion, create `.planning/phases/02-stateful-core/02-05-SUMMARY.md`
</output>
