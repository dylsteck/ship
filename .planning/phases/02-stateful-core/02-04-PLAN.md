---
phase: 02-stateful-core
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - apps/api/src/routes/chat.ts
  - apps/api/src/durable-objects/session.ts
  - apps/api/src/index.ts
autonomous: true

must_haves:
  truths:
    - "User message is persisted in DO SQLite"
    - "Messages can be retrieved with pagination"
    - "Chat endpoint accepts message and returns stream"
    - "Assistant messages are stored after completion"
  artifacts:
    - path: "apps/api/src/routes/chat.ts"
      provides: "Chat endpoint with SSE streaming"
      exports: ["default"]
      min_lines: 50
    - path: "apps/api/src/durable-objects/session.ts"
      provides: "Message persistence methods"
      contains: "persistMessage"
      min_lines: 180
  key_links:
    - from: "apps/api/src/routes/chat.ts"
      to: "SessionDO"
      via: "DO stub RPC"
      pattern: "stub\\.persistMessage|stub\\.getMessages"
    - from: "apps/api/src/durable-objects/session.ts"
      to: "SQLite messages table"
      via: "sql.exec INSERT"
      pattern: "INSERT INTO messages"
---

<objective>
Implement chat API and message persistence in Durable Objects.

Purpose: Chat is the primary interaction mode. Users send messages, they're persisted, and responses stream back. This delivers SESS-02 (chat with persistence) and prepares for OpenCode integration in Plan 02-06.

Output: Chat endpoint that persists messages to DO SQLite and returns SSE stream for responses.
</objective>

<execution_context>
@/Users/dylansteck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-stateful-core/02-RESEARCH.md
@.planning/phases/02-stateful-core/02-01-SUMMARY.md
@.planning/phases/02-stateful-core/02-03-SUMMARY.md

# Existing files
@apps/api/src/durable-objects/session.ts
@apps/api/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add message persistence methods to SessionDO</name>
  <files>apps/api/src/durable-objects/session.ts</files>
  <action>
Extend SessionDO with message CRUD operations.

Add these methods to SessionDO class:

1. Message types:
```typescript
interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  parts?: string; // JSON array of tool parts
  createdAt: number;
}

interface MessagePart {
  type: 'text' | 'tool-call' | 'tool-result';
  content?: string;
  toolName?: string;
  toolInput?: unknown;
  toolOutput?: unknown;
  state?: 'pending' | 'running' | 'complete' | 'error';
}
```

2. persistMessage - Save a message:
```typescript
async persistMessage(message: Omit<Message, 'id' | 'createdAt'>): Promise<Message> {
  const id = crypto.randomUUID();
  const createdAt = Math.floor(Date.now() / 1000);

  this.sql.exec(
    `INSERT INTO messages (id, role, content, parts, created_at)
     VALUES (?, ?, ?, ?, ?)`,
    id,
    message.role,
    message.content,
    message.parts || null,
    createdAt
  );

  const saved = { id, ...message, createdAt };

  // Broadcast to WebSocket clients
  this.broadcast({ type: 'message', message: saved });

  return saved;
}
```

3. getMessages - Get messages with pagination:
```typescript
async getMessages(options: { limit?: number; before?: string } = {}): Promise<Message[]> {
  const limit = options.limit || 25; // Default ~25 per CONTEXT.md

  let query = `SELECT id, role, content, parts, created_at as createdAt
               FROM messages`;
  const params: unknown[] = [];

  if (options.before) {
    // Get cursor message's created_at
    const cursor = this.sql.exec(
      `SELECT created_at FROM messages WHERE id = ?`,
      options.before
    ).one();

    if (cursor) {
      query += ` WHERE created_at < ?`;
      params.push(cursor.created_at);
    }
  }

  query += ` ORDER BY created_at DESC LIMIT ?`;
  params.push(limit);

  const rows = this.sql.exec(query, ...params).toArray();

  // Return in chronological order (oldest first)
  return rows.reverse().map(row => ({
    id: row.id as string,
    role: row.role as Message['role'],
    content: row.content as string,
    parts: row.parts as string | undefined,
    createdAt: row.createdAt as number,
  }));
}
```

4. updateMessageParts - Update streaming message parts:
```typescript
async updateMessageParts(messageId: string, parts: string): Promise<void> {
  this.sql.exec(
    `UPDATE messages SET parts = ? WHERE id = ?`,
    parts,
    messageId
  );

  // Broadcast part update
  this.broadcast({ type: 'message-parts', messageId, parts });
}
```

5. getMessageCount - For session list display:
```typescript
async getMessageCount(): Promise<number> {
  const result = this.sql.exec(`SELECT COUNT(*) as count FROM messages`).one();
  return (result?.count as number) || 0;
}
```

Also update the fetch handler to expose RPC endpoints:
```typescript
async fetch(request: Request): Promise<Response> {
  const url = new URL(request.url);

  // WebSocket upgrade
  if (url.pathname.endsWith('/websocket')) {
    // ... existing code
  }

  // RPC: Get messages
  if (url.pathname.endsWith('/messages') && request.method === 'GET') {
    const limit = url.searchParams.get('limit');
    const before = url.searchParams.get('before');
    const messages = await this.getMessages({
      limit: limit ? parseInt(limit) : undefined,
      before: before || undefined,
    });
    return Response.json(messages);
  }

  // RPC: Persist message
  if (url.pathname.endsWith('/messages') && request.method === 'POST') {
    const body = await request.json() as Omit<Message, 'id' | 'createdAt'>;
    const message = await this.persistMessage(body);
    return Response.json(message);
  }

  return new Response('Not found', { status: 404 });
}
```
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
Message methods exist on SessionDO class.
  </verify>
  <done>SessionDO has message persistence with SQLite and WebSocket broadcast.</done>
</task>

<task type="auto">
  <name>Task 2: Create chat API route with SSE streaming</name>
  <files>apps/api/src/routes/chat.ts, apps/api/src/index.ts</files>
  <action>
Create chat endpoint that handles message submission and SSE streaming.

Create apps/api/src/routes/chat.ts:
```typescript
import { Hono } from 'hono';
import { streamSSE } from 'hono/streaming';

interface Env {
  SESSION_DO: DurableObjectNamespace;
  DB: D1Database;
}

const app = new Hono<{ Bindings: Env }>();

// POST /chat/:sessionId - Send message and receive streaming response
app.post('/:sessionId', async (c) => {
  const sessionId = c.req.param('sessionId');
  const { content } = await c.req.json<{ content: string }>();

  if (!content?.trim()) {
    return c.json({ error: 'Message content required' }, 400);
  }

  // Get DO stub
  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  // Persist user message via DO RPC
  const doUrl = new URL(`https://do/messages`);
  await stub.fetch(new Request(doUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ role: 'user', content }),
  }));

  // For Phase 2, return simple SSE that acknowledges message
  // OpenCode integration happens in Plan 02-06
  return streamSSE(c, async (stream) => {
    // Send acknowledgment
    await stream.writeSSE({
      event: 'message',
      data: JSON.stringify({ type: 'ack', content: 'Message received' }),
    });

    // Placeholder for assistant response
    // In Plan 02-06, this will stream OpenCode events
    const assistantMessage = {
      role: 'assistant' as const,
      content: 'I received your message. Agent integration coming in Phase 2 Plan 06.',
    };

    // Persist assistant message
    await stub.fetch(new Request(doUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(assistantMessage),
    }));

    // Stream completion
    await stream.writeSSE({
      event: 'message',
      data: JSON.stringify({ type: 'assistant', ...assistantMessage }),
    });

    await stream.writeSSE({
      event: 'done',
      data: JSON.stringify({ type: 'done' }),
    });
  });
});

// GET /chat/:sessionId/messages - Get message history
app.get('/:sessionId/messages', async (c) => {
  const sessionId = c.req.param('sessionId');
  const limit = c.req.query('limit');
  const before = c.req.query('before');

  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  const params = new URLSearchParams();
  if (limit) params.set('limit', limit);
  if (before) params.set('before', before);

  const response = await stub.fetch(
    new Request(`https://do/messages?${params}`)
  );

  const messages = await response.json();
  return c.json(messages);
});

export default app;
```

Add to index.ts:
```typescript
import chat from './routes/chat'
app.route('/chat', chat)
```

The SSE stream structure follows CONTEXT.md pattern:
- event: 'message' for content chunks
- event: 'done' for completion
- Real streaming with tool calls will be added in Plan 02-06
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
Test endpoints:
- `curl http://localhost:8787/chat/test-session/messages` returns []
- `curl -X POST http://localhost:8787/chat/test-session -d '{"content":"Hello"}' -H "Content-Type: application/json"` returns SSE stream
  </verify>
  <done>Chat API with message persistence and SSE streaming placeholder.</done>
</task>

</tasks>

<verification>
1. `pnpm -F api build` passes
2. Start API with `pnpm -F api dev`
3. Send test message:
   ```
   curl -X POST http://localhost:8787/chat/test-session \
     -H "Content-Type: application/json" \
     -d '{"content":"Hello"}'
   ```
4. Retrieve messages:
   ```
   curl http://localhost:8787/chat/test-session/messages
   ```
5. Verify messages persisted (should see user message and assistant placeholder)
6. WebSocket clients receive message broadcasts
</verification>

<success_criteria>
- Messages persist in DO SQLite (Success Criteria #2 - messages persist)
- Chat endpoint accepts POST with content
- SSE stream returns response events
- GET messages endpoint supports pagination
- WebSocket broadcasts new messages
- Foundation ready for chat UI (Plan 02-05) and OpenCode (Plan 02-06)
</success_criteria>

<output>
After completion, create `.planning/phases/02-stateful-core/02-04-SUMMARY.md`
</output>
