---
phase: 02-stateful-core
plan: 07
type: execute
wave: 6
depends_on: ["02-05", "02-06"]
files_modified:
  - apps/web/components/session/session-panel.tsx
  - apps/web/components/session/status-indicator.tsx
  - apps/web/app/(app)/session/[id]/page.tsx
  - apps/web/components/chat/chat-interface.tsx
autonomous: false

must_haves:
  truths:
    - "Side panel shows repo context and current branch"
    - "Side panel shows active tasks and their status"
    - "Status indicator shows high-level agent state"
    - "Tool calls expand to show details"
    - "Session state survives page reload"
  artifacts:
    - path: "apps/web/components/session/session-panel.tsx"
      provides: "Side panel with session context"
      exports: ["SessionPanel"]
      min_lines: 60
    - path: "apps/web/components/session/status-indicator.tsx"
      provides: "Agent status indicator"
      exports: ["StatusIndicator"]
      min_lines: 30
  key_links:
    - from: "apps/web/app/(app)/session/[id]/page.tsx"
      to: "apps/web/components/session/session-panel.tsx"
      via: "component import"
      pattern: "SessionPanel"
    - from: "apps/web/components/session/session-panel.tsx"
      to: "/chat/:sessionId/tasks"
      via: "task fetch"
      pattern: "fetch.*tasks"
---

<objective>
Add session side panel and status indicators, then verify complete phase.

Purpose: The side panel provides context while chatting - showing repo, branch, and current tasks. Status indicators let users know what the agent is doing at a glance. This completes the Phase 2 user experience and delivers remaining success criteria.

Output: Complete session UI with side panel, status indicators, and human verification of all features.
</objective>

<execution_context>
@/Users/dylansteck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-stateful-core/02-CONTEXT.md
@.planning/phases/02-stateful-core/02-05-SUMMARY.md
@.planning/phases/02-stateful-core/02-06-SUMMARY.md

# Existing files
@apps/web/app/(app)/session/[id]/page.tsx
@apps/web/components/chat/chat-interface.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session panel and status indicator components</name>
  <files>apps/web/components/session/session-panel.tsx, apps/web/components/session/status-indicator.tsx</files>
  <action>
Create the side panel and status indicator components per CONTEXT.md decisions.

1. Create apps/web/components/session/status-indicator.tsx:
Per CONTEXT.md: "High-level status by default ('Planning', 'Coding', 'Testing'), expandable to see detailed tool calls"
```tsx
'use client';

import { useState } from 'react';

export type AgentStatus = 'idle' | 'planning' | 'coding' | 'testing' | 'waiting' | 'error';

interface StatusIndicatorProps {
  status: AgentStatus;
  currentTool?: string;
  expanded?: boolean;
  onToggleExpand?: () => void;
}

const statusConfig: Record<AgentStatus, { label: string; color: string; animate: boolean }> = {
  idle: { label: 'Idle', color: 'bg-gray-400', animate: false },
  planning: { label: 'Planning', color: 'bg-blue-500', animate: true },
  coding: { label: 'Coding', color: 'bg-green-500', animate: true },
  testing: { label: 'Testing', color: 'bg-purple-500', animate: true },
  waiting: { label: 'Waiting', color: 'bg-yellow-500', animate: true },
  error: { label: 'Error', color: 'bg-red-500', animate: false },
};

export function StatusIndicator({ status, currentTool, expanded, onToggleExpand }: StatusIndicatorProps) {
  const config = statusConfig[status];

  return (
    <div className="flex items-center gap-2">
      <div className={`w-2 h-2 rounded-full ${config.color} ${config.animate ? 'animate-pulse' : ''}`} />
      <span className="text-sm font-medium">{config.label}</span>

      {currentTool && (
        <button
          onClick={onToggleExpand}
          className="text-xs text-gray-500 hover:text-gray-700"
        >
          {expanded ? 'Hide' : 'Show'} details
        </button>
      )}

      {expanded && currentTool && (
        <span className="text-xs text-gray-500 font-mono">
          {currentTool}
        </span>
      )}
    </div>
  );
}
```

2. Create apps/web/components/session/session-panel.tsx:
Per CONTEXT.md: "Mini side panel shows: repo context, current branch, active tasks/tools being used"
```tsx
'use client';

import { useEffect, useState } from 'react';
import { StatusIndicator, AgentStatus } from './status-indicator';

interface Task {
  id: string;
  title: string;
  description?: string;
  status: 'pending' | 'running' | 'complete' | 'error';
  mode: 'build' | 'plan';
  createdAt: number;
}

interface SessionInfo {
  repoOwner: string;
  repoName: string;
  branch?: string;
}

interface SessionPanelProps {
  sessionId: string;
  sessionInfo: SessionInfo;
  agentStatus: AgentStatus;
  currentTool?: string;
}

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8787';

export function SessionPanel({ sessionId, sessionInfo, agentStatus, currentTool }: SessionPanelProps) {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [showStatusDetails, setShowStatusDetails] = useState(false);

  // Fetch tasks
  useEffect(() => {
    async function loadTasks() {
      try {
        const res = await fetch(`${API_URL}/chat/${sessionId}/tasks`);
        if (res.ok) {
          setTasks(await res.json());
        }
      } catch (err) {
        console.error('Failed to load tasks:', err);
      }
    }
    loadTasks();

    // Refresh every 5 seconds while agent is active
    if (agentStatus !== 'idle' && agentStatus !== 'error') {
      const interval = setInterval(loadTasks, 5000);
      return () => clearInterval(interval);
    }
  }, [sessionId, agentStatus]);

  const activeTasks = tasks.filter(t => t.status === 'pending' || t.status === 'running');
  const completedTasks = tasks.filter(t => t.status === 'complete');

  return (
    <div className="w-64 border-l bg-gray-50 flex flex-col">
      {/* Repo Context */}
      <div className="p-4 border-b">
        <h3 className="text-xs font-semibold text-gray-500 uppercase mb-2">Repository</h3>
        <div className="font-medium text-sm">
          {sessionInfo.repoOwner}/{sessionInfo.repoName}
        </div>
        {sessionInfo.branch && (
          <div className="text-xs text-gray-500 mt-1 font-mono">
            {sessionInfo.branch}
          </div>
        )}
      </div>

      {/* Agent Status */}
      <div className="p-4 border-b">
        <h3 className="text-xs font-semibold text-gray-500 uppercase mb-2">Status</h3>
        <StatusIndicator
          status={agentStatus}
          currentTool={currentTool}
          expanded={showStatusDetails}
          onToggleExpand={() => setShowStatusDetails(!showStatusDetails)}
        />
      </div>

      {/* Active Tasks */}
      {activeTasks.length > 0 && (
        <div className="p-4 border-b">
          <h3 className="text-xs font-semibold text-gray-500 uppercase mb-2">
            Active Tasks ({activeTasks.length})
          </h3>
          <div className="space-y-2">
            {activeTasks.map(task => (
              <div
                key={task.id}
                className={`p-2 rounded text-sm ${
                  task.status === 'running' ? 'bg-blue-100' : 'bg-gray-100'
                }`}
              >
                <div className="font-medium">{task.title}</div>
                <div className="text-xs text-gray-500 capitalize">
                  {task.mode} mode - {task.status}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Completed Tasks */}
      {completedTasks.length > 0 && (
        <div className="p-4 flex-1 overflow-y-auto">
          <h3 className="text-xs font-semibold text-gray-500 uppercase mb-2">
            Completed ({completedTasks.length})
          </h3>
          <div className="space-y-1">
            {completedTasks.slice(-5).map(task => (
              <div key={task.id} className="text-xs text-gray-500">
                {task.title}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

Per CONTEXT.md: "Tasks managed through chat only - no direct manipulation in side panel"
The side panel is read-only - shows tasks but doesn't allow editing.
  </action>
  <verify>
Run `pnpm -F web build` - compiles without errors.
Components exist and export correctly.
  </verify>
  <done>SessionPanel and StatusIndicator components created.</done>
</task>

<task type="auto">
  <name>Task 2: Update session page with side panel and status tracking</name>
  <files>apps/web/app/(app)/session/[id]/page.tsx, apps/web/components/chat/chat-interface.tsx</files>
  <action>
Integrate side panel into session page and add status tracking to chat interface.

1. Update apps/web/components/chat/chat-interface.tsx to expose status:
Add state and callbacks for agent status tracking:
```tsx
// Add to ChatInterface props
interface ChatInterfaceProps {
  sessionId: string;
  onStatusChange?: (status: AgentStatus, currentTool?: string) => void;
}

// In component, derive status from streaming state and events
// When streaming starts: 'planning' or 'coding' based on tool calls
// When tool-call event: update currentTool
// When idle: 'idle'
// When error: 'error'

// In the SSE processing loop, detect tool calls:
if (data.type === 'event' && data.event?.part?.type === 'tool-call') {
  const toolName = data.event.part.toolName;
  // Map tool names to high-level status
  let status: AgentStatus = 'coding';
  if (toolName?.includes('plan') || toolName?.includes('think')) {
    status = 'planning';
  } else if (toolName?.includes('test') || toolName?.includes('run')) {
    status = 'testing';
  }
  onStatusChange?.(status, toolName);
}
```

2. Update apps/web/app/(app)/session/[id]/page.tsx to include side panel:
```tsx
'use client';

import { useState, useEffect } from 'react';
import { ChatInterface } from '@/components/chat/chat-interface';
import { SessionPanel } from '@/components/session/session-panel';
import { AgentStatus } from '@/components/session/status-indicator';
import Link from 'next/link';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8787';

interface SessionPageClientProps {
  sessionId: string;
}

function SessionPageClient({ sessionId }: SessionPageClientProps) {
  const [agentStatus, setAgentStatus] = useState<AgentStatus>('idle');
  const [currentTool, setCurrentTool] = useState<string>();
  const [sessionInfo, setSessionInfo] = useState({
    repoOwner: '',
    repoName: '',
    branch: undefined as string | undefined,
  });

  // Fetch session info
  useEffect(() => {
    async function loadSession() {
      try {
        const res = await fetch(`${API_URL}/sessions/${sessionId}`);
        if (res.ok) {
          const data = await res.json();
          setSessionInfo({
            repoOwner: data.repoOwner,
            repoName: data.repoName,
            branch: data.branch,
          });
        }
      } catch (err) {
        console.error('Failed to load session:', err);
      }
    }
    loadSession();
  }, [sessionId]);

  const handleStatusChange = (status: AgentStatus, tool?: string) => {
    setAgentStatus(status);
    setCurrentTool(tool);
  };

  return (
    <div className="flex flex-col h-screen">
      {/* Header */}
      <header className="flex items-center justify-between px-4 py-3 border-b bg-white">
        <div className="flex items-center gap-4">
          <Link
            href="/dashboard"
            className="text-gray-500 hover:text-gray-700"
          >
            &larr; Back
          </Link>
          <h1 className="font-semibold">
            {sessionInfo.repoOwner && sessionInfo.repoName
              ? `${sessionInfo.repoOwner}/${sessionInfo.repoName}`
              : 'Session'}
          </h1>
        </div>
      </header>

      {/* Main content: Chat + Side Panel */}
      <div className="flex-1 flex overflow-hidden">
        {/* Chat Interface */}
        <div className="flex-1 overflow-hidden">
          <ChatInterface
            sessionId={sessionId}
            onStatusChange={handleStatusChange}
          />
        </div>

        {/* Side Panel */}
        <SessionPanel
          sessionId={sessionId}
          sessionInfo={sessionInfo}
          agentStatus={agentStatus}
          currentTool={currentTool}
        />
      </div>
    </div>
  );
}

// Server component wrapper for auth check
import { verifySession } from '@/lib/dal';

interface SessionPageProps {
  params: Promise<{ id: string }>;
}

export default async function SessionPage({ params }: SessionPageProps) {
  await verifySession();
  const { id: sessionId } = await params;

  return <SessionPageClient sessionId={sessionId} />;
}
```

Note: We need to split into server/client components for auth + client-side state.
  </action>
  <verify>
Run `pnpm -F web build` - compiles without errors.
Session page renders with side panel.
  </verify>
  <done>Session page includes side panel with status tracking.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2: Stateful Core functionality including:
- Session CRUD (create, list, delete sessions)
- Durable Object state persistence with SQLite
- WebSocket real-time updates with hibernation support
- Chat interface with message persistence
- OpenCode SDK integration for agent execution
- Task system with FIFO ordering
- Session side panel with status indicators
  </what-built>
  <how-to-verify>
1. Start both services:
   ```bash
   cd apps/api && pnpm dev
   cd apps/web && pnpm dev
   ```

2. Test Session Management (Success Criteria #1):
   - Navigate to http://localhost:3000/dashboard
   - Click "New Session"
   - Enter repo owner and name
   - Session should appear in list
   - Click session to open chat

3. Test Chat with Persistence (Success Criteria #2):
   - Send a message in chat
   - Verify message appears in list
   - Refresh the page (Cmd+R)
   - Verify message persists after reload
   - Click "Load earlier" if messages exist

4. Test Real-time Updates (Success Criteria #5):
   - Open same session in two browser tabs
   - Send message in one tab
   - Verify message appears in both tabs via WebSocket

5. Test Hibernation (Success Criteria #4):
   - Send a message
   - Wait 30+ seconds (DO should hibernate)
   - Send another message
   - Verify previous messages still exist (state survived)

6. Test Stop and Queue (from CONTEXT.md):
   - Start a message
   - Click Stop - streaming should stop
   - Send message while streaming - should queue
   - When streaming ends, queued message sends

7. Test Side Panel:
   - Verify repo name shows in side panel
   - Verify status indicator updates during agent activity
   - Verify tasks appear when agent creates them

8. Test Task Creation (Success Criteria #3, #6):
   - Send message that triggers task creation
   - Verify task appears in side panel
   - Send another task-triggering message
   - Verify multiple tasks show

Note: OpenCode integration requires OpenCode server running.
If not available, agent responses will be placeholder.
  </how-to-verify>
  <resume-signal>Type "approved" if all criteria pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
See human verification checkpoint above.
</verification>

<success_criteria>
All Phase 2 Success Criteria verified:
1. User can create a new session and it appears in session list
2. User can chat with agent in a session and messages persist across page reloads
3. User can create tasks from chat messages and tasks appear in session
4. Session state survives Durable Object hibernation and wakes correctly
5. User sees real-time status updates when agent is working (via WebSocket)
6. User can add multiple tasks to one session and tasks execute in order
</success_criteria>

<output>
After completion, create `.planning/phases/02-stateful-core/02-07-SUMMARY.md`
</output>
