---
phase: 02-stateful-core
plan: 06
type: execute
wave: 5
depends_on: ["02-04"]
files_modified:
  - apps/api/src/lib/opencode.ts
  - apps/api/src/routes/chat.ts
  - apps/api/src/durable-objects/session.ts
  - apps/api/package.json
autonomous: true

user_setup:
  - service: opencode
    why: "Agent runtime server for executing tasks"
    dashboard_config:
      - task: "Install OpenCode CLI globally"
        location: "Terminal: npm install -g opencode"
      - task: "Configure opencode.json in repo root"
        location: "Create .opencode/config.json with provider settings"

must_haves:
  truths:
    - "OpenCode SDK is installed and configured"
    - "Chat messages trigger OpenCode agent"
    - "Agent events stream to client"
    - "Tasks are created from agent activity"
    - "Tasks have FIFO ordering"
  artifacts:
    - path: "apps/api/src/lib/opencode.ts"
      provides: "OpenCode SDK wrapper"
      exports: ["getOpenCodeClient", "createOpenCodeSession"]
      min_lines: 40
    - path: "apps/api/src/routes/chat.ts"
      provides: "Chat with OpenCode integration"
      contains: "opencode"
      min_lines: 100
    - path: "apps/api/src/durable-objects/session.ts"
      provides: "Task persistence"
      contains: "persistTask"
      min_lines: 250
  key_links:
    - from: "apps/api/src/routes/chat.ts"
      to: "apps/api/src/lib/opencode.ts"
      via: "OpenCode client"
      pattern: "getOpenCodeClient|createOpenCodeSession"
    - from: "apps/api/src/routes/chat.ts"
      to: "SessionDO"
      via: "Task persistence"
      pattern: "persistTask"
---

<objective>
Integrate OpenCode SDK for agent execution with task system.

Purpose: This is the brain of the application - where user messages become agent actions. OpenCode SDK handles LLM calls, tool execution, and streaming. We persist tasks created by the agent and ensure FIFO execution order. Delivers SESS-03 (task creation), SESS-06 (multiple tasks), SESS-07 (FIFO order).

Output: Working agent integration that creates and executes tasks from chat messages.
</objective>

<execution_context>
@/Users/dylansteck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylansteck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-stateful-core/02-RESEARCH.md
@.planning/phases/02-stateful-core/02-CONTEXT.md
@.planning/phases/02-stateful-core/02-04-SUMMARY.md

# Existing files
@apps/api/src/routes/chat.ts
@apps/api/src/durable-objects/session.ts
@apps/api/src/lib/opencode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install OpenCode SDK and create wrapper</name>
  <files>apps/api/package.json, apps/api/src/lib/opencode.ts</files>
  <action>
Install OpenCode SDK and create a wrapper for consistent usage.

1. Install the SDK:
```bash
cd apps/api && pnpm add @opencode-ai/sdk
```

2. Create apps/api/src/lib/opencode.ts:
```typescript
/**
 * OpenCode SDK wrapper for agent execution
 *
 * OpenCode provides the complete agent runtime:
 * - Build mode (execute immediately) and Plan mode (propose first)
 * - Tool execution (file ops, shell, code editing)
 * - SSE streaming with rich event types
 *
 * We do NOT make direct LLM calls - OpenCode handles everything.
 */

import { createOpencode, createOpencodeClient } from '@opencode-ai/sdk';

// Types for OpenCode events (based on SDK)
export interface OpenCodeEvent {
  type: 'part' | 'session.idle' | 'session.error' | 'permission.request';
  part?: {
    type: 'text' | 'tool-call' | 'tool-result';
    content?: string;
    toolName?: string;
    toolInput?: unknown;
    toolOutput?: unknown;
    state?: 'pending' | 'running' | 'complete' | 'error';
  };
  error?: string;
  permission?: {
    id: string;
    action: string;
    description: string;
  };
}

export interface OpenCodeSession {
  id: string;
  projectPath: string;
}

// Singleton client - OpenCode server should be running
let client: Awaited<ReturnType<typeof createOpencodeClient>> | null = null;

/**
 * Get or create OpenCode client
 * Connects to existing OpenCode server (must be running)
 */
export async function getOpenCodeClient() {
  if (!client) {
    // For development, auto-start server
    // For production, connect to existing server
    const isDev = process.env.ENVIRONMENT === 'development';

    if (isDev) {
      // Auto-start server in development
      client = await createOpencode({
        hostname: '127.0.0.1',
        port: 4096,
        config: {
          provider: 'anthropic',
          model: 'claude-sonnet-4-20250514',
        },
      });
    } else {
      // Connect to existing server in production
      client = await createOpencodeClient({
        hostname: process.env.OPENCODE_HOST || '127.0.0.1',
        port: parseInt(process.env.OPENCODE_PORT || '4096'),
      });
    }
  }
  return client;
}

/**
 * Create a new OpenCode session for a project
 */
export async function createOpenCodeSession(projectPath: string): Promise<OpenCodeSession> {
  const opencode = await getOpenCodeClient();
  const session = await opencode.session.create({ path: projectPath });
  return {
    id: session.id,
    projectPath,
  };
}

/**
 * Send a prompt to OpenCode session and return event iterator
 */
export async function promptOpenCode(
  sessionId: string,
  content: string,
  options?: { mode?: 'build' | 'plan' }
) {
  const opencode = await getOpenCodeClient();

  // Subscribe to events BEFORE sending prompt
  const events = opencode.event.subscribe();

  // Send prompt with mode
  // Note: Mode handling depends on OpenCode SDK API
  // May need to be session-level or prompt-level setting
  await opencode.session.prompt(sessionId, { content });

  return events;
}

/**
 * Stop the current OpenCode session activity
 */
export async function stopOpenCode(sessionId: string) {
  const opencode = await getOpenCodeClient();
  await opencode.session.stop(sessionId);
}

/**
 * Respond to permission request
 */
export async function respondToPermission(
  sessionId: string,
  permissionId: string,
  approved: boolean
) {
  const opencode = await getOpenCodeClient();
  await opencode.permission.respond(sessionId, permissionId, approved);
}
```

IMPORTANT notes from CONTEXT.md:
- "Agent infers intent from natural language and breaks down into tasks automatically (like Claude Code)"
- "Two modes: Build mode (default, execute immediately) and Plan mode (propose first, user confirms)"
- OpenCode handles this - we just need to pass mode setting
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
OpenCode client wrapper exports correctly.
  </verify>
  <done>OpenCode SDK installed and wrapper created.</done>
</task>

<task type="auto">
  <name>Task 2: Add task persistence to SessionDO</name>
  <files>apps/api/src/durable-objects/session.ts</files>
  <action>
Extend SessionDO with task CRUD operations and FIFO queue management.

Add these methods and types to SessionDO:

1. Task types:
```typescript
interface Task {
  id: string;
  title: string;
  description?: string;
  status: 'pending' | 'running' | 'complete' | 'error';
  mode: 'build' | 'plan';
  createdAt: number;
  completedAt?: number;
}
```

2. persistTask - Create a new task:
```typescript
async persistTask(task: Omit<Task, 'id' | 'createdAt' | 'status'>): Promise<Task> {
  const id = crypto.randomUUID();
  const createdAt = Math.floor(Date.now() / 1000);

  this.sql.exec(
    `INSERT INTO tasks (id, title, description, status, mode, created_at)
     VALUES (?, ?, ?, 'pending', ?, ?)`,
    id,
    task.title,
    task.description || null,
    task.mode,
    createdAt
  );

  const saved: Task = {
    id,
    title: task.title,
    description: task.description,
    status: 'pending',
    mode: task.mode,
    createdAt,
  };

  // Broadcast to WebSocket clients
  this.broadcast({ type: 'task-created', task: saved });

  return saved;
}
```

3. updateTaskStatus - Update task status (for FIFO processing):
```typescript
async updateTaskStatus(
  taskId: string,
  status: Task['status'],
  completedAt?: number
): Promise<void> {
  this.sql.exec(
    `UPDATE tasks SET status = ?, completed_at = ? WHERE id = ?`,
    status,
    completedAt || null,
    taskId
  );

  this.broadcast({ type: 'task-updated', taskId, status, completedAt });
}
```

4. getNextPendingTask - Get next task in FIFO order:
```typescript
async getNextPendingTask(): Promise<Task | null> {
  const row = this.sql.exec(
    `SELECT id, title, description, status, mode, created_at as createdAt, completed_at as completedAt
     FROM tasks
     WHERE status = 'pending'
     ORDER BY created_at ASC
     LIMIT 1`
  ).one();

  if (!row) return null;

  return {
    id: row.id as string,
    title: row.title as string,
    description: row.description as string | undefined,
    status: row.status as Task['status'],
    mode: row.mode as Task['mode'],
    createdAt: row.createdAt as number,
    completedAt: row.completedAt as number | undefined,
  };
}
```

5. getTasks - Get all tasks with optional status filter:
```typescript
async getTasks(options?: { status?: Task['status']; limit?: number }): Promise<Task[]> {
  let query = `SELECT id, title, description, status, mode, created_at as createdAt, completed_at as completedAt
               FROM tasks`;
  const params: unknown[] = [];

  if (options?.status) {
    query += ` WHERE status = ?`;
    params.push(options.status);
  }

  query += ` ORDER BY created_at ASC`;

  if (options?.limit) {
    query += ` LIMIT ?`;
    params.push(options.limit);
  }

  const rows = this.sql.exec(query, ...params).toArray();

  return rows.map(row => ({
    id: row.id as string,
    title: row.title as string,
    description: row.description as string | undefined,
    status: row.status as Task['status'],
    mode: row.mode as Task['mode'],
    createdAt: row.createdAt as number,
    completedAt: row.completedAt as number | undefined,
  }));
}
```

6. Add RPC endpoints in fetch():
```typescript
// RPC: Get tasks
if (url.pathname.endsWith('/tasks') && request.method === 'GET') {
  const status = url.searchParams.get('status') as Task['status'] | null;
  const tasks = await this.getTasks({ status: status || undefined });
  return Response.json(tasks);
}

// RPC: Create task
if (url.pathname.endsWith('/tasks') && request.method === 'POST') {
  const body = await request.json() as Omit<Task, 'id' | 'createdAt' | 'status'>;
  const task = await this.persistTask(body);
  return Response.json(task);
}
```

IMPORTANT from CONTEXT.md:
- "Tasks managed through chat only - no direct manipulation in side panel"
- Tasks are created by the agent, not manually by users
- FIFO order: "Tasks process in FIFO order" (SESS-07)
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
Task methods exist on SessionDO class.
  </verify>
  <done>SessionDO has task persistence with FIFO queue support.</done>
</task>

<task type="auto">
  <name>Task 3: Update chat route with OpenCode integration</name>
  <files>apps/api/src/routes/chat.ts</files>
  <action>
Update the chat route to use OpenCode SDK for agent execution.

Replace the placeholder implementation with real OpenCode integration:
```typescript
import { Hono } from 'hono';
import { streamSSE } from 'hono/streaming';
import {
  getOpenCodeClient,
  createOpenCodeSession,
  promptOpenCode,
  stopOpenCode,
  OpenCodeEvent,
} from '../lib/opencode';

interface Env {
  SESSION_DO: DurableObjectNamespace;
  DB: D1Database;
}

const app = new Hono<{ Bindings: Env }>();

// POST /chat/:sessionId - Send message and receive streaming response
app.post('/:sessionId', async (c) => {
  const sessionId = c.req.param('sessionId');
  const { content, mode = 'build' } = await c.req.json<{
    content: string;
    mode?: 'build' | 'plan';
  }>();

  if (!content?.trim()) {
    return c.json({ error: 'Message content required' }, 400);
  }

  // Get DO stub
  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  // Persist user message
  const doUrl = 'https://do';
  await stub.fetch(new Request(`${doUrl}/messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ role: 'user', content }),
  }));

  // Get or create OpenCode session for this session
  const metaRes = await stub.fetch(new Request(`${doUrl}/meta`));
  let meta = await metaRes.json() as Record<string, string>;
  let opencodeSessionId = meta.opencodeSessionId;

  if (!opencodeSessionId) {
    // Create new OpenCode session
    // TODO: In Phase 3, this will use the actual repo path from sandbox
    const projectPath = meta.repoPath || '/tmp/ship-session';
    const ocSession = await createOpenCodeSession(projectPath);
    opencodeSessionId = ocSession.id;

    // Save to session meta
    await stub.fetch(new Request(`${doUrl}/meta`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ opencodeSessionId }),
    }));
  }

  // Stream OpenCode events as SSE
  return streamSSE(c, async (stream) => {
    try {
      // Send prompt to OpenCode
      const events = await promptOpenCode(opencodeSessionId!, content, { mode });

      // Accumulate assistant message content
      let assistantContent = '';
      const parts: Array<{
        type: string;
        content?: string;
        toolName?: string;
        toolInput?: unknown;
        toolOutput?: unknown;
        state?: string;
      }> = [];

      // Process events
      for await (const event of events) {
        const ocEvent = event as OpenCodeEvent;

        // Stream event to client
        await stream.writeSSE({
          event: 'event',
          data: JSON.stringify(ocEvent),
        });

        // Broadcast to WebSocket clients via DO
        await stub.fetch(new Request(`${doUrl}/broadcast`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: 'opencode-event', event: ocEvent }),
        }));

        // Handle different event types
        if (ocEvent.type === 'part' && ocEvent.part) {
          if (ocEvent.part.type === 'text' && ocEvent.part.content) {
            assistantContent += ocEvent.part.content;
          }

          if (ocEvent.part.type === 'tool-call') {
            parts.push({
              type: 'tool-call',
              toolName: ocEvent.part.toolName,
              toolInput: ocEvent.part.toolInput,
              state: ocEvent.part.state,
            });

            // If this looks like a task breakdown, create a task
            // Agent infers tasks from natural language per CONTEXT.md
            if (ocEvent.part.toolName === 'create_task' && ocEvent.part.toolInput) {
              const input = ocEvent.part.toolInput as { title: string; description?: string };
              await stub.fetch(new Request(`${doUrl}/tasks`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  title: input.title,
                  description: input.description,
                  mode,
                }),
              }));
            }
          }

          if (ocEvent.part.type === 'tool-result') {
            // Update last tool-call with result
            const lastToolCall = parts.findLast(p => p.type === 'tool-call');
            if (lastToolCall) {
              lastToolCall.toolOutput = ocEvent.part.toolOutput;
              lastToolCall.state = 'complete';
            }
          }
        }

        if (ocEvent.type === 'permission.request') {
          // Forward permission request to client
          // Client will respond via WebSocket
          await stream.writeSSE({
            event: 'permission',
            data: JSON.stringify(ocEvent.permission),
          });
        }

        if (ocEvent.type === 'session.idle') {
          // Agent finished
          break;
        }

        if (ocEvent.type === 'session.error') {
          await stream.writeSSE({
            event: 'error',
            data: JSON.stringify({ error: ocEvent.error }),
          });
          break;
        }
      }

      // Persist assistant message with accumulated content and parts
      if (assistantContent || parts.length > 0) {
        await stub.fetch(new Request(`${doUrl}/messages`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            role: 'assistant',
            content: assistantContent,
            parts: JSON.stringify(parts),
          }),
        }));
      }

      await stream.writeSSE({
        event: 'done',
        data: JSON.stringify({ type: 'done' }),
      });

    } catch (error) {
      console.error('OpenCode error:', error);
      await stream.writeSSE({
        event: 'error',
        data: JSON.stringify({ error: 'Agent execution failed' }),
      });
    }
  });
});

// POST /chat/:sessionId/stop - Stop streaming
app.post('/:sessionId/stop', async (c) => {
  const sessionId = c.req.param('sessionId');

  // Get OpenCode session ID from DO
  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  const metaRes = await stub.fetch(new Request('https://do/meta'));
  const meta = await metaRes.json() as Record<string, string>;

  if (meta.opencodeSessionId) {
    await stopOpenCode(meta.opencodeSessionId);
  }

  return c.json({ success: true });
});

// GET /chat/:sessionId/messages - Get message history
app.get('/:sessionId/messages', async (c) => {
  const sessionId = c.req.param('sessionId');
  const limit = c.req.query('limit');
  const before = c.req.query('before');

  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  const params = new URLSearchParams();
  if (limit) params.set('limit', limit);
  if (before) params.set('before', before);

  const response = await stub.fetch(
    new Request(`https://do/messages?${params}`)
  );

  return new Response(response.body, response);
});

// GET /chat/:sessionId/tasks - Get tasks
app.get('/:sessionId/tasks', async (c) => {
  const sessionId = c.req.param('sessionId');
  const status = c.req.query('status');

  const id = c.env.SESSION_DO.idFromName(sessionId);
  const stub = c.env.SESSION_DO.get(id);

  const params = new URLSearchParams();
  if (status) params.set('status', status);

  const response = await stub.fetch(
    new Request(`https://do/tasks?${params}`)
  );

  return new Response(response.body, response);
});

export default app;
```

Also add the /meta and /broadcast RPC endpoints to SessionDO (in separate file update):
- GET /meta - Return session metadata
- POST /meta - Update session metadata (merge with existing)
- POST /broadcast - Broadcast message to WebSocket clients
  </action>
  <verify>
Run `pnpm -F api build` - compiles without errors.
Chat route handles OpenCode events.
  </verify>
  <done>Chat route integrated with OpenCode SDK for agent execution.</done>
</task>

</tasks>

<verification>
1. `pnpm -F api build` passes
2. Start OpenCode server: `opencode serve` (or let SDK auto-start)
3. Start API: `pnpm -F api dev`
4. Send chat message - see OpenCode events in SSE stream
5. Verify tasks created in DO when agent creates them
6. Verify messages persisted with tool parts
7. Stop button stops OpenCode execution
</verification>

<success_criteria>
- OpenCode SDK processes chat messages
- Agent events stream to client via SSE
- Tasks created from agent activity (Success Criteria #3)
- Multiple tasks can be added to session (Success Criteria #6)
- Tasks process in FIFO order (SESS-07)
- Build/Plan mode toggle works
</success_criteria>

<output>
After completion, create `.planning/phases/02-stateful-core/02-06-SUMMARY.md`
</output>
